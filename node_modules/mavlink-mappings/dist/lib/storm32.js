"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMMANDS = exports.REGISTRY = exports.QshotDoConfigureCommand = exports.Storm32DoGimbalManagerSetupCommand = exports.Storm32DoGimbalManagerControlPitchyawCommand = exports.ParamValueArray = exports.FrskyPassthroughArray = exports.RadioLinkStats = exports.RadioRcChannels = exports.Storm32GimbalManagerCorrectRoll = exports.Storm32GimbalManagerControlPitchyaw = exports.Storm32GimbalManagerControl = exports.Storm32GimbalManagerStatus = exports.Storm32GimbalManagerInformation = exports.RadioLinkStatsFlags = exports.RadioRcChannelsFlags = exports.MavCmd = exports.MavQshotMode = exports.MavStorm32GimbalManagerProfile = exports.MavStorm32GimbalManagerClient = exports.MavStorm32GimbalManagerFlags = exports.MavStorm32GimbalManagerCapFlags = exports.MavStorm32CameraPrearmFlags = exports.MavStorm32GimbalPrearmFlags = exports.MavStorm32TunnelPayloadType = void 0;
const mavlink_1 = require("./mavlink");
const common_1 = require("./common");
/**
 * MAV_STORM32_TUNNEL_PAYLOAD_TYPE
 */
var MavStorm32TunnelPayloadType;
(function (MavStorm32TunnelPayloadType) {
    /**
     * Registered for STorM32 gimbal controller. For communication with gimbal or camera.
     */
    MavStorm32TunnelPayloadType[MavStorm32TunnelPayloadType["STORM32_CH1_IN"] = 200] = "STORM32_CH1_IN";
    /**
     * Registered for STorM32 gimbal controller. For communication with gimbal or camera.
     */
    MavStorm32TunnelPayloadType[MavStorm32TunnelPayloadType["STORM32_CH1_OUT"] = 201] = "STORM32_CH1_OUT";
    /**
     * Registered for STorM32 gimbal controller. For communication with gimbal.
     */
    MavStorm32TunnelPayloadType[MavStorm32TunnelPayloadType["STORM32_CH2_IN"] = 202] = "STORM32_CH2_IN";
    /**
     * Registered for STorM32 gimbal controller. For communication with gimbal.
     */
    MavStorm32TunnelPayloadType[MavStorm32TunnelPayloadType["STORM32_CH2_OUT"] = 203] = "STORM32_CH2_OUT";
    /**
     * Registered for STorM32 gimbal controller. For communication with camera.
     */
    MavStorm32TunnelPayloadType[MavStorm32TunnelPayloadType["STORM32_CH3_IN"] = 204] = "STORM32_CH3_IN";
    /**
     * Registered for STorM32 gimbal controller. For communication with camera.
     */
    MavStorm32TunnelPayloadType[MavStorm32TunnelPayloadType["STORM32_CH3_OUT"] = 205] = "STORM32_CH3_OUT";
})(MavStorm32TunnelPayloadType = exports.MavStorm32TunnelPayloadType || (exports.MavStorm32TunnelPayloadType = {}));
/**
 * STorM32 gimbal prearm check flags.
 */
var MavStorm32GimbalPrearmFlags;
(function (MavStorm32GimbalPrearmFlags) {
    /**
     * STorM32 gimbal is in normal state.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["IS_NORMAL"] = 1] = "IS_NORMAL";
    /**
     * The IMUs are healthy and working normally.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["IMUS_WORKING"] = 2] = "IMUS_WORKING";
    /**
     * The motors are active and working normally.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["MOTORS_WORKING"] = 4] = "MOTORS_WORKING";
    /**
     * The encoders are healthy and working normally.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["ENCODERS_WORKING"] = 8] = "ENCODERS_WORKING";
    /**
     * A battery voltage is applied and is in range.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["VOLTAGE_OK"] = 16] = "VOLTAGE_OK";
    /**
     * Virtual input channels are receiving data.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["VIRTUALCHANNELS_RECEIVING"] = 32] = "VIRTUALCHANNELS_RECEIVING";
    /**
     * Mavlink messages are being received.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["MAVLINK_RECEIVING"] = 64] = "MAVLINK_RECEIVING";
    /**
     * The STorM32Link data indicates QFix.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["STORM32LINK_QFIX"] = 128] = "STORM32LINK_QFIX";
    /**
     * The STorM32Link is working.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["STORM32LINK_WORKING"] = 256] = "STORM32LINK_WORKING";
    /**
     * The camera has been found and is connected.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["CAMERA_CONNECTED"] = 512] = "CAMERA_CONNECTED";
    /**
     * The signal on the AUX0 input pin is low.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["AUX0_LOW"] = 1024] = "AUX0_LOW";
    /**
     * The signal on the AUX1 input pin is low.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["AUX1_LOW"] = 2048] = "AUX1_LOW";
    /**
     * The NTLogger is working normally.
     */
    MavStorm32GimbalPrearmFlags[MavStorm32GimbalPrearmFlags["NTLOGGER_WORKING"] = 4096] = "NTLOGGER_WORKING";
})(MavStorm32GimbalPrearmFlags = exports.MavStorm32GimbalPrearmFlags || (exports.MavStorm32GimbalPrearmFlags = {}));
/**
 * STorM32 camera prearm check flags.
 */
var MavStorm32CameraPrearmFlags;
(function (MavStorm32CameraPrearmFlags) {
    /**
     * The camera has been found and is connected.
     */
    MavStorm32CameraPrearmFlags[MavStorm32CameraPrearmFlags["CONNECTED"] = 1] = "CONNECTED";
})(MavStorm32CameraPrearmFlags = exports.MavStorm32CameraPrearmFlags || (exports.MavStorm32CameraPrearmFlags = {}));
/**
 * Gimbal manager capability flags.
 */
var MavStorm32GimbalManagerCapFlags;
(function (MavStorm32GimbalManagerCapFlags) {
    /**
     * The gimbal manager supports several profiles.
     */
    MavStorm32GimbalManagerCapFlags[MavStorm32GimbalManagerCapFlags["HAS_PROFILES"] = 1] = "HAS_PROFILES";
})(MavStorm32GimbalManagerCapFlags = exports.MavStorm32GimbalManagerCapFlags || (exports.MavStorm32GimbalManagerCapFlags = {}));
/**
 * Flags for gimbal manager operation. Used for setting and reporting, unless specified otherwise. If a
 * setting has been accepted by the gimbal manager is reported in the STORM32_GIMBAL_MANAGER_STATUS
 * message.
 */
var MavStorm32GimbalManagerFlags;
(function (MavStorm32GimbalManagerFlags) {
    /**
     * 0 = ignore.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["NONE"] = 0] = "NONE";
    /**
     * Request to set RC input to active, or report RC input is active. Implies RC mixed. RC exclusive is
     * achieved by setting all clients to inactive.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["RC_ACTIVE"] = 1] = "RC_ACTIVE";
    /**
     * Request to set onboard/companion computer client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_ONBOARD_ACTIVE"] = 2] = "CLIENT_ONBOARD_ACTIVE";
    /**
     * Request to set autopliot client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_AUTOPILOT_ACTIVE"] = 4] = "CLIENT_AUTOPILOT_ACTIVE";
    /**
     * Request to set GCS client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_GCS_ACTIVE"] = 8] = "CLIENT_GCS_ACTIVE";
    /**
     * Request to set camera client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_CAMERA_ACTIVE"] = 16] = "CLIENT_CAMERA_ACTIVE";
    /**
     * Request to set GCS2 client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_GCS2_ACTIVE"] = 32] = "CLIENT_GCS2_ACTIVE";
    /**
     * Request to set camera2 client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_CAMERA2_ACTIVE"] = 64] = "CLIENT_CAMERA2_ACTIVE";
    /**
     * Request to set custom client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_CUSTOM_ACTIVE"] = 128] = "CLIENT_CUSTOM_ACTIVE";
    /**
     * Request to set custom2 client to active, or report this client is active.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["CLIENT_CUSTOM2_ACTIVE"] = 256] = "CLIENT_CUSTOM2_ACTIVE";
    /**
     * Request supervision. This flag is only for setting, it is not reported.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["SET_SUPERVISON"] = 512] = "SET_SUPERVISON";
    /**
     * Release supervision. This flag is only for setting, it is not reported.
     */
    MavStorm32GimbalManagerFlags[MavStorm32GimbalManagerFlags["SET_RELEASE"] = 1024] = "SET_RELEASE";
})(MavStorm32GimbalManagerFlags = exports.MavStorm32GimbalManagerFlags || (exports.MavStorm32GimbalManagerFlags = {}));
/**
 * Gimbal manager client ID. In a prioritizing profile, the priorities are determined by the
 * implementation; they could e.g. be custom1 > onboard > GCS > autopilot/camera > GCS2 > custom2.
 */
var MavStorm32GimbalManagerClient;
(function (MavStorm32GimbalManagerClient) {
    /**
     * For convenience.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["NONE"] = 0] = "NONE";
    /**
     * This is the onboard/companion computer client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["ONBOARD"] = 1] = "ONBOARD";
    /**
     * This is the autopilot client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["AUTOPILOT"] = 2] = "AUTOPILOT";
    /**
     * This is the GCS client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["GCS"] = 3] = "GCS";
    /**
     * This is the camera client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["CAMERA"] = 4] = "CAMERA";
    /**
     * This is the GCS2 client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["GCS2"] = 5] = "GCS2";
    /**
     * This is the camera2 client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["CAMERA2"] = 6] = "CAMERA2";
    /**
     * This is the custom client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["CUSTOM"] = 7] = "CUSTOM";
    /**
     * This is the custom2 client.
     */
    MavStorm32GimbalManagerClient[MavStorm32GimbalManagerClient["CUSTOM2"] = 8] = "CUSTOM2";
})(MavStorm32GimbalManagerClient = exports.MavStorm32GimbalManagerClient || (exports.MavStorm32GimbalManagerClient = {}));
/**
 * Gimbal manager profiles. Only standard profiles are defined. Any implementation can define its own
 * profile(s) in addition, and should use enum values > 16.
 */
var MavStorm32GimbalManagerProfile;
(function (MavStorm32GimbalManagerProfile) {
    /**
     * Default profile. Implementation specific.
     */
    MavStorm32GimbalManagerProfile[MavStorm32GimbalManagerProfile["DEFAULT"] = 0] = "DEFAULT";
    /**
     * Not supported/deprecated.
     */
    MavStorm32GimbalManagerProfile[MavStorm32GimbalManagerProfile["CUSTOM"] = 1] = "CUSTOM";
    /**
     * Profile with cooperative behavior.
     */
    MavStorm32GimbalManagerProfile[MavStorm32GimbalManagerProfile["COOPERATIVE"] = 2] = "COOPERATIVE";
    /**
     * Profile with exclusive behavior.
     */
    MavStorm32GimbalManagerProfile[MavStorm32GimbalManagerProfile["EXCLUSIVE"] = 3] = "EXCLUSIVE";
    /**
     * Profile with priority and cooperative behavior for equal priority.
     */
    MavStorm32GimbalManagerProfile[MavStorm32GimbalManagerProfile["PRIORITY_COOPERATIVE"] = 4] = "PRIORITY_COOPERATIVE";
    /**
     * Profile with priority and exclusive behavior for equal priority.
     */
    MavStorm32GimbalManagerProfile[MavStorm32GimbalManagerProfile["PRIORITY_EXCLUSIVE"] = 5] = "PRIORITY_EXCLUSIVE";
})(MavStorm32GimbalManagerProfile = exports.MavStorm32GimbalManagerProfile || (exports.MavStorm32GimbalManagerProfile = {}));
/**
 * Enumeration of possible shot modes.
 */
var MavQshotMode;
(function (MavQshotMode) {
    /**
     * Undefined shot mode. Can be used to determine if qshots should be used or not.
     */
    MavQshotMode[MavQshotMode["UNDEFINED"] = 0] = "UNDEFINED";
    /**
     * Start normal gimbal operation. Is usually used to return back from a shot.
     */
    MavQshotMode[MavQshotMode["DEFAULT"] = 1] = "DEFAULT";
    /**
     * Load and keep safe gimbal position and stop stabilization.
     */
    MavQshotMode[MavQshotMode["GIMBAL_RETRACT"] = 2] = "GIMBAL_RETRACT";
    /**
     * Load neutral gimbal position and keep it while stabilizing.
     */
    MavQshotMode[MavQshotMode["GIMBAL_NEUTRAL"] = 3] = "GIMBAL_NEUTRAL";
    /**
     * Start mission with gimbal control.
     */
    MavQshotMode[MavQshotMode["GIMBAL_MISSION"] = 4] = "GIMBAL_MISSION";
    /**
     * Start RC gimbal control.
     */
    MavQshotMode[MavQshotMode["GIMBAL_RC_CONTROL"] = 5] = "GIMBAL_RC_CONTROL";
    /**
     * Start gimbal tracking the point specified by Lat, Lon, Alt.
     */
    MavQshotMode[MavQshotMode["POI_TARGETING"] = 6] = "POI_TARGETING";
    /**
     * Start gimbal tracking the system with specified system ID.
     */
    MavQshotMode[MavQshotMode["SYSID_TARGETING"] = 7] = "SYSID_TARGETING";
    /**
     * Start 2-point cable cam quick shot.
     */
    MavQshotMode[MavQshotMode["CABLECAM_2POINT"] = 8] = "CABLECAM_2POINT";
    /**
     * Start gimbal tracking the home location.
     */
    MavQshotMode[MavQshotMode["HOME_TARGETING"] = 9] = "HOME_TARGETING";
})(MavQshotMode = exports.MavQshotMode || (exports.MavQshotMode = {}));
/**
 * MAV_CMD
 */
var MavCmd;
(function (MavCmd) {
    /**
     * Command to a gimbal manager to control the gimbal tilt and pan angles. It is possible to set
     * combinations of the values below. E.g. an angle as well as a desired angular rate can be used to get
     * to this angle at a certain angular rate, or an angular rate only will result in continuous turning.
     * NaN is to be used to signal unset. A gimbal device is never to react to this command.
     * @param1 Pitch angle[deg] (min: -180, max: 180) Pitch/tilt angle (positive: tilt up). NaN to be ignored.
     * @param2 Yaw angle[deg] (min: -180, max: 180) Yaw/pan angle (positive: pan to the right). NaN to be ignored. The frame is determined by the GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
     * @param3 Pitch rate[deg/s] Pitch/tilt rate (positive: tilt up). NaN to be ignored.
     * @param4 Yaw rate[deg/s] Yaw/pan rate (positive: pan to the right). NaN to be ignored. The frame is determined by the GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
     * @param5 Gimbal device flags Gimbal device flags to be applied.
     * @param6 Gimbal manager flags Gimbal manager flags to be applied.
     * @param7 Gimbal ID and client Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all gimbals). Send command multiple times for more than one but not all gimbals. The client is copied into bits 8-15.
     */
    MavCmd[MavCmd["STORM32_DO_GIMBAL_MANAGER_CONTROL_PITCHYAW"] = 60002] = "STORM32_DO_GIMBAL_MANAGER_CONTROL_PITCHYAW";
    /**
     * Command to configure a gimbal manager. A gimbal device is never to react to this command. The
     * selected profile is reported in the STORM32_GIMBAL_MANAGER_STATUS message.
     * @param1 Profile Gimbal manager profile (0 = default).
     * @param7 Gimbal ID Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all gimbals). Send command multiple times for more than one but not all gimbals.
     */
    MavCmd[MavCmd["STORM32_DO_GIMBAL_MANAGER_SETUP"] = 60010] = "STORM32_DO_GIMBAL_MANAGER_SETUP";
    /**
     * Command to set the shot manager mode.
     * @param1 Mode Set shot mode.
     * @param2 Shot state or command Set shot state or command. The allowed values are specific to the selected shot mode.
     */
    MavCmd[MavCmd["QSHOT_DO_CONFIGURE"] = 60020] = "QSHOT_DO_CONFIGURE";
})(MavCmd = exports.MavCmd || (exports.MavCmd = {}));
/**
 * RADIO_RC_CHANNELS flags (bitmask).
 */
var RadioRcChannelsFlags;
(function (RadioRcChannelsFlags) {
    /**
     * Failsafe is active.
     */
    RadioRcChannelsFlags[RadioRcChannelsFlags["FAILSAFE"] = 1] = "FAILSAFE";
    /**
     * Indicates that the current frame has not been received. Channel values are frozen.
     */
    RadioRcChannelsFlags[RadioRcChannelsFlags["FRAME_MISSED"] = 2] = "FRAME_MISSED";
})(RadioRcChannelsFlags = exports.RadioRcChannelsFlags || (exports.RadioRcChannelsFlags = {}));
/**
 * RADIO_LINK_STATS flags (bitmask).
 */
var RadioLinkStatsFlags;
(function (RadioLinkStatsFlags) {
    /**
     * Rssi are in negative dBm. Values 0..254 corresponds to 0..-254 dBm.
     */
    RadioLinkStatsFlags[RadioLinkStatsFlags["RSSI_DBM"] = 1] = "RSSI_DBM";
})(RadioLinkStatsFlags = exports.RadioLinkStatsFlags || (exports.RadioLinkStatsFlags = {}));
/**
 * Information about a gimbal manager. This message should be requested by a ground station using
 * MAV_CMD_REQUEST_MESSAGE. It mirrors some fields of the GIMBAL_DEVICE_INFORMATION message, but not
 * all. If the additional information is desired, also GIMBAL_DEVICE_INFORMATION should be requested.
 */
class Storm32GimbalManagerInformation extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.gimbalId = 0;
        this.deviceCapFlags = common_1.GimbalDeviceCapFlags[Object.keys(common_1.GimbalDeviceCapFlags)[0]];
        this.managerCapFlags = MavStorm32GimbalManagerCapFlags[Object.keys(MavStorm32GimbalManagerCapFlags)[0]];
        this.rollMin = 0;
        this.rollMax = 0;
        this.pitchMin = 0;
        this.pitchMax = 0;
        this.yawMin = 0;
        this.yawMax = 0;
    }
}
exports.Storm32GimbalManagerInformation = Storm32GimbalManagerInformation;
Storm32GimbalManagerInformation.MSG_ID = 60010;
Storm32GimbalManagerInformation.MSG_NAME = 'STORM32_GIMBAL_MANAGER_INFORMATION';
Storm32GimbalManagerInformation.PAYLOAD_LENGTH = 33;
Storm32GimbalManagerInformation.MAGIC_NUMBER = 208;
Storm32GimbalManagerInformation.FIELDS = [
    new mavlink_1.MavLinkPacketField('device_cap_flags', 'deviceCapFlags', 0, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('manager_cap_flags', 'managerCapFlags', 4, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('roll_min', 'rollMin', 8, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('roll_max', 'rollMax', 12, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('pitch_min', 'pitchMin', 16, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('pitch_max', 'pitchMax', 20, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('yaw_min', 'yawMin', 24, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('yaw_max', 'yawMax', 28, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('gimbal_id', 'gimbalId', 32, false, 1, 'uint8_t', ''),
];
/**
 * Message reporting the current status of a gimbal manager. This message should be broadcast at a low
 * regular rate (e.g. 1 Hz, may be increase momentarily to e.g. 5 Hz for a period of 1 sec after a
 * change).
 */
class Storm32GimbalManagerStatus extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.gimbalId = 0;
        this.supervisor = MavStorm32GimbalManagerClient[Object.keys(MavStorm32GimbalManagerClient)[0]];
        this.deviceFlags = common_1.GimbalDeviceFlags[Object.keys(common_1.GimbalDeviceFlags)[0]];
        this.managerFlags = MavStorm32GimbalManagerFlags[Object.keys(MavStorm32GimbalManagerFlags)[0]];
        this.profile = MavStorm32GimbalManagerProfile[Object.keys(MavStorm32GimbalManagerProfile)[0]];
    }
}
exports.Storm32GimbalManagerStatus = Storm32GimbalManagerStatus;
Storm32GimbalManagerStatus.MSG_ID = 60011;
Storm32GimbalManagerStatus.MSG_NAME = 'STORM32_GIMBAL_MANAGER_STATUS';
Storm32GimbalManagerStatus.PAYLOAD_LENGTH = 7;
Storm32GimbalManagerStatus.MAGIC_NUMBER = 183;
Storm32GimbalManagerStatus.FIELDS = [
    new mavlink_1.MavLinkPacketField('device_flags', 'deviceFlags', 0, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('manager_flags', 'managerFlags', 2, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('gimbal_id', 'gimbalId', 4, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('supervisor', 'supervisor', 5, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('profile', 'profile', 6, false, 1, 'uint8_t', ''),
];
/**
 * Message to a gimbal manager to control the gimbal attitude. Angles and rates can be set to NaN
 * according to use case. A gimbal device is never to react to this message.
 */
class Storm32GimbalManagerControl extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.targetSystem = 0;
        this.targetComponent = 0;
        this.gimbalId = 0;
        this.client = MavStorm32GimbalManagerClient[Object.keys(MavStorm32GimbalManagerClient)[0]];
        this.deviceFlags = common_1.GimbalDeviceFlags[Object.keys(common_1.GimbalDeviceFlags)[0]];
        this.managerFlags = MavStorm32GimbalManagerFlags[Object.keys(MavStorm32GimbalManagerFlags)[0]];
        this.q = [];
        this.angularVelocityX = 0;
        this.angularVelocityY = 0;
        this.angularVelocityZ = 0;
    }
}
exports.Storm32GimbalManagerControl = Storm32GimbalManagerControl;
Storm32GimbalManagerControl.MSG_ID = 60012;
Storm32GimbalManagerControl.MSG_NAME = 'STORM32_GIMBAL_MANAGER_CONTROL';
Storm32GimbalManagerControl.PAYLOAD_LENGTH = 36;
Storm32GimbalManagerControl.MAGIC_NUMBER = 99;
Storm32GimbalManagerControl.FIELDS = [
    new mavlink_1.MavLinkPacketField('q', 'q', 0, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('angular_velocity_x', 'angularVelocityX', 16, false, 4, 'float', 'rad/s'),
    new mavlink_1.MavLinkPacketField('angular_velocity_y', 'angularVelocityY', 20, false, 4, 'float', 'rad/s'),
    new mavlink_1.MavLinkPacketField('angular_velocity_z', 'angularVelocityZ', 24, false, 4, 'float', 'rad/s'),
    new mavlink_1.MavLinkPacketField('device_flags', 'deviceFlags', 28, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('manager_flags', 'managerFlags', 30, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('target_system', 'targetSystem', 32, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('target_component', 'targetComponent', 33, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('gimbal_id', 'gimbalId', 34, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('client', 'client', 35, false, 1, 'uint8_t', ''),
];
/**
 * Message to a gimbal manager to control the gimbal tilt and pan angles. Angles and rates can be set
 * to NaN according to use case. A gimbal device is never to react to this message.
 */
class Storm32GimbalManagerControlPitchyaw extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.targetSystem = 0;
        this.targetComponent = 0;
        this.gimbalId = 0;
        this.client = MavStorm32GimbalManagerClient[Object.keys(MavStorm32GimbalManagerClient)[0]];
        this.deviceFlags = common_1.GimbalDeviceFlags[Object.keys(common_1.GimbalDeviceFlags)[0]];
        this.managerFlags = MavStorm32GimbalManagerFlags[Object.keys(MavStorm32GimbalManagerFlags)[0]];
        this.pitch = 0;
        this.yaw = 0;
        this.pitchRate = 0;
        this.yawRate = 0;
    }
}
exports.Storm32GimbalManagerControlPitchyaw = Storm32GimbalManagerControlPitchyaw;
Storm32GimbalManagerControlPitchyaw.MSG_ID = 60013;
Storm32GimbalManagerControlPitchyaw.MSG_NAME = 'STORM32_GIMBAL_MANAGER_CONTROL_PITCHYAW';
Storm32GimbalManagerControlPitchyaw.PAYLOAD_LENGTH = 24;
Storm32GimbalManagerControlPitchyaw.MAGIC_NUMBER = 129;
Storm32GimbalManagerControlPitchyaw.FIELDS = [
    new mavlink_1.MavLinkPacketField('pitch', 'pitch', 0, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('yaw', 'yaw', 4, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('pitch_rate', 'pitchRate', 8, false, 4, 'float', 'rad/s'),
    new mavlink_1.MavLinkPacketField('yaw_rate', 'yawRate', 12, false, 4, 'float', 'rad/s'),
    new mavlink_1.MavLinkPacketField('device_flags', 'deviceFlags', 16, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('manager_flags', 'managerFlags', 18, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('target_system', 'targetSystem', 20, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('target_component', 'targetComponent', 21, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('gimbal_id', 'gimbalId', 22, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('client', 'client', 23, false, 1, 'uint8_t', ''),
];
/**
 * Message to a gimbal manager to correct the gimbal roll angle. This message is typically used to
 * manually correct for a tilted horizon in operation. A gimbal device is never to react to this
 * message.
 */
class Storm32GimbalManagerCorrectRoll extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.targetSystem = 0;
        this.targetComponent = 0;
        this.gimbalId = 0;
        this.client = MavStorm32GimbalManagerClient[Object.keys(MavStorm32GimbalManagerClient)[0]];
        this.roll = 0;
    }
}
exports.Storm32GimbalManagerCorrectRoll = Storm32GimbalManagerCorrectRoll;
Storm32GimbalManagerCorrectRoll.MSG_ID = 60014;
Storm32GimbalManagerCorrectRoll.MSG_NAME = 'STORM32_GIMBAL_MANAGER_CORRECT_ROLL';
Storm32GimbalManagerCorrectRoll.PAYLOAD_LENGTH = 8;
Storm32GimbalManagerCorrectRoll.MAGIC_NUMBER = 134;
Storm32GimbalManagerCorrectRoll.FIELDS = [
    new mavlink_1.MavLinkPacketField('roll', 'roll', 0, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('target_system', 'targetSystem', 4, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('target_component', 'targetComponent', 5, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('gimbal_id', 'gimbalId', 6, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('client', 'client', 7, false, 1, 'uint8_t', ''),
];
/**
 * Radio channels. Supports up to 24 channels. Channel values are in centerd 13 bit format. Range is
 * [-4096,4096], center is 0. Conversion to PWM is x * 5/32 + 1500. Should be emitted only by
 * components with component id MAV_COMP_ID_TELEMETRY_RADIO.
 */
class RadioRcChannels extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.count = 0;
        this.flags = RadioRcChannelsFlags[Object.keys(RadioRcChannelsFlags)[0]];
        this.channels = [];
    }
}
exports.RadioRcChannels = RadioRcChannels;
RadioRcChannels.MSG_ID = 60045;
RadioRcChannels.MSG_NAME = 'RADIO_RC_CHANNELS';
RadioRcChannels.PAYLOAD_LENGTH = 50;
RadioRcChannels.MAGIC_NUMBER = 89;
RadioRcChannels.FIELDS = [
    new mavlink_1.MavLinkPacketField('count', 'count', 0, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 1, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('channels', 'channels', 2, true, 2, 'int16_t[]', '', 24),
];
/**
 * Radio link statistics. Should be emitted only by components with component id
 * MAV_COMP_ID_TELEMETRY_RADIO. Per default, rssi values are in MAVLink units: 0 represents weakest
 * signal, 254 represents maximum signal; can be changed to dBm with the flag
 * RADIO_LINK_STATS_FLAGS_RSSI_DBM.
 */
class RadioLinkStats extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.flags = RadioLinkStatsFlags[Object.keys(RadioLinkStatsFlags)[0]];
        this.rxLQ = 0;
        this.rxRssi1 = 0;
        this.rxSnr1 = 0;
        this.rxRssi2 = 0;
        this.rxSnr2 = 0;
        this.rxReceiveAntenna = 0;
        this.rxTransmitAntenna = 0;
        this.txLQ = 0;
        this.txRssi1 = 0;
        this.txSnr1 = 0;
        this.txRssi2 = 0;
        this.txSnr2 = 0;
        this.txReceiveAntenna = 0;
        this.txTransmitAntenna = 0;
    }
}
exports.RadioLinkStats = RadioLinkStats;
RadioLinkStats.MSG_ID = 60046;
RadioLinkStats.MSG_NAME = 'RADIO_LINK_STATS';
RadioLinkStats.PAYLOAD_LENGTH = 15;
RadioLinkStats.MAGIC_NUMBER = 238;
RadioLinkStats.FIELDS = [
    new mavlink_1.MavLinkPacketField('flags', 'flags', 0, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('rx_LQ', 'rxLQ', 1, false, 1, 'uint8_t', 'c%'),
    new mavlink_1.MavLinkPacketField('rx_rssi1', 'rxRssi1', 2, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('rx_snr1', 'rxSnr1', 3, false, 1, 'int8_t', ''),
    new mavlink_1.MavLinkPacketField('rx_rssi2', 'rxRssi2', 4, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('rx_snr2', 'rxSnr2', 5, false, 1, 'int8_t', ''),
    new mavlink_1.MavLinkPacketField('rx_receive_antenna', 'rxReceiveAntenna', 6, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('rx_transmit_antenna', 'rxTransmitAntenna', 7, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('tx_LQ', 'txLQ', 8, false, 1, 'uint8_t', 'c%'),
    new mavlink_1.MavLinkPacketField('tx_rssi1', 'txRssi1', 9, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('tx_snr1', 'txSnr1', 10, false, 1, 'int8_t', ''),
    new mavlink_1.MavLinkPacketField('tx_rssi2', 'txRssi2', 11, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('tx_snr2', 'txSnr2', 12, false, 1, 'int8_t', ''),
    new mavlink_1.MavLinkPacketField('tx_receive_antenna', 'txReceiveAntenna', 13, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('tx_transmit_antenna', 'txTransmitAntenna', 14, false, 1, 'uint8_t', ''),
];
/**
 * Frsky SPort passthrough multi packet container.
 */
class FrskyPassthroughArray extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.timeBootMs = 0;
        this.count = 0;
        this.packetBuf = [];
    }
}
exports.FrskyPassthroughArray = FrskyPassthroughArray;
FrskyPassthroughArray.MSG_ID = 60040;
FrskyPassthroughArray.MSG_NAME = 'FRSKY_PASSTHROUGH_ARRAY';
FrskyPassthroughArray.PAYLOAD_LENGTH = 245;
FrskyPassthroughArray.MAGIC_NUMBER = 156;
FrskyPassthroughArray.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_boot_ms', 'timeBootMs', 0, false, 4, 'uint32_t', 'ms'),
    new mavlink_1.MavLinkPacketField('count', 'count', 4, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('packet_buf', 'packetBuf', 5, false, 1, 'uint8_t[]', '', 240),
];
/**
 * Parameter multi param value container.
 */
class ParamValueArray extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.paramCount = 0;
        this.paramIndexFirst = 0;
        this.paramArrayLen = 0;
        this.flags = 0;
        this.packetBuf = [];
    }
}
exports.ParamValueArray = ParamValueArray;
ParamValueArray.MSG_ID = 60041;
ParamValueArray.MSG_NAME = 'PARAM_VALUE_ARRAY';
ParamValueArray.PAYLOAD_LENGTH = 255;
ParamValueArray.MAGIC_NUMBER = 191;
ParamValueArray.FIELDS = [
    new mavlink_1.MavLinkPacketField('param_count', 'paramCount', 0, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('param_index_first', 'paramIndexFirst', 2, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 4, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('param_array_len', 'paramArrayLen', 6, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('packet_buf', 'packetBuf', 7, false, 1, 'uint8_t[]', '', 248),
];
const common_2 = require("./common");
/**
 * Command to a gimbal manager to control the gimbal tilt and pan angles. It is possible to set
 * combinations of the values below. E.g. an angle as well as a desired angular rate can be used to get
 * to this angle at a certain angular rate, or an angular rate only will result in continuous turning.
 * NaN is to be used to signal unset. A gimbal device is never to react to this command.
 */
class Storm32DoGimbalManagerControlPitchyawCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.STORM32_DO_GIMBAL_MANAGER_CONTROL_PITCHYAW;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Pitch/tilt angle (positive: tilt up). NaN to be ignored.
     *
     * @units deg
     * @min: -180
     * @max: 180
     */
    get pitchAngle() {
        return this._param1;
    }
    set pitchAngle(value) {
        this._param1 = value;
    }
    /**
     * Yaw/pan angle (positive: pan to the right). NaN to be ignored. The frame is determined by the
     * GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
     *
     * @units deg
     * @min: -180
     * @max: 180
     */
    get yawAngle() {
        return this._param2;
    }
    set yawAngle(value) {
        this._param2 = value;
    }
    /**
     * Pitch/tilt rate (positive: tilt up). NaN to be ignored.
     *
     * @units deg/s
     */
    get pitchRate() {
        return this._param3;
    }
    set pitchRate(value) {
        this._param3 = value;
    }
    /**
     * Yaw/pan rate (positive: pan to the right). NaN to be ignored. The frame is determined by the
     * GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
     *
     * @units deg/s
     */
    get yawRate() {
        return this._param4;
    }
    set yawRate(value) {
        this._param4 = value;
    }
    /**
     * Gimbal device flags to be applied.
     */
    get gimbalDeviceFlags() {
        return this._param5;
    }
    set gimbalDeviceFlags(value) {
        this._param5 = value;
    }
    /**
     * Gimbal manager flags to be applied.
     */
    get gimbalManagerFlags() {
        return this._param6;
    }
    set gimbalManagerFlags(value) {
        this._param6 = value;
    }
    /**
     * Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all
     * gimbals). Send command multiple times for more than one but not all gimbals. The client is copied
     * into bits 8-15.
     */
    get gimbalIdAndClient() {
        return this._param7;
    }
    set gimbalIdAndClient(value) {
        this._param7 = value;
    }
}
exports.Storm32DoGimbalManagerControlPitchyawCommand = Storm32DoGimbalManagerControlPitchyawCommand;
/**
 * Command to configure a gimbal manager. A gimbal device is never to react to this command. The
 * selected profile is reported in the STORM32_GIMBAL_MANAGER_STATUS message.
 */
class Storm32DoGimbalManagerSetupCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.STORM32_DO_GIMBAL_MANAGER_SETUP;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Gimbal manager profile (0 = default).
     */
    get profile() {
        return this._param1;
    }
    set profile(value) {
        this._param1 = value;
    }
    /**
     * Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all
     * gimbals). Send command multiple times for more than one but not all gimbals.
     */
    get gimbalId() {
        return this._param7;
    }
    set gimbalId(value) {
        this._param7 = value;
    }
}
exports.Storm32DoGimbalManagerSetupCommand = Storm32DoGimbalManagerSetupCommand;
/**
 * Command to set the shot manager mode.
 */
class QshotDoConfigureCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.QSHOT_DO_CONFIGURE;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Set shot mode.
     */
    get mode() {
        return this._param1;
    }
    set mode(value) {
        this._param1 = value;
    }
    /**
     * Set shot state or command. The allowed values are specific to the selected shot mode.
     */
    get shotStateOrCommand() {
        return this._param2;
    }
    set shotStateOrCommand(value) {
        this._param2 = value;
    }
}
exports.QshotDoConfigureCommand = QshotDoConfigureCommand;
exports.REGISTRY = {
    60010: Storm32GimbalManagerInformation,
    60011: Storm32GimbalManagerStatus,
    60012: Storm32GimbalManagerControl,
    60013: Storm32GimbalManagerControlPitchyaw,
    60014: Storm32GimbalManagerCorrectRoll,
    60045: RadioRcChannels,
    60046: RadioLinkStats,
    60040: FrskyPassthroughArray,
    60041: ParamValueArray,
};
exports.COMMANDS = {
    [MavCmd.STORM32_DO_GIMBAL_MANAGER_CONTROL_PITCHYAW]: Storm32DoGimbalManagerControlPitchyawCommand,
    [MavCmd.STORM32_DO_GIMBAL_MANAGER_SETUP]: Storm32DoGimbalManagerSetupCommand,
    [MavCmd.QSHOT_DO_CONFIGURE]: QshotDoConfigureCommand,
};
//# sourceMappingURL=storm32.js.map