"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMMANDS = exports.REGISTRY = exports.SetAtSParamCommand = exports.DoSetStandardModeCommand = exports.GroupEndCommand = exports.GroupStartCommand = exports.DoUpgradeCommand = exports.ParamTransactionCommand = exports.DoFigureEightCommand = exports.TargetRelative = exports.TargetAbsolute = exports.AvailableModesMonitor = exports.CurrentMode = exports.AvailableModes = exports.GroupEnd = exports.GroupStart = exports.ComponentInformationBasic = exports.BatteryStatusV2 = exports.WifiNetworkInfo = exports.Airspeed = exports.ParamAckTransaction = exports.TargetObsFrame = exports.TargetAbsoluteSensorCapabilityFlags = exports.MavCmd = exports.MavBatteryStatusFlags = exports.MavModeProperty = exports.MavStandardMode = exports.ParamTransactionAction = exports.ParamTransactionTransport = exports.AirspeedSensorFlags = exports.WifiNetworkSecurity = void 0;
const mavlink_1 = require("./mavlink");
const common_1 = require("./common");
/**
 * WiFi wireless security protocols.
 */
var WifiNetworkSecurity;
(function (WifiNetworkSecurity) {
    /**
     * Undefined or unknown security protocol.
     */
    WifiNetworkSecurity[WifiNetworkSecurity["UNDEFINED"] = 0] = "UNDEFINED";
    /**
     * Open network, no security.
     */
    WifiNetworkSecurity[WifiNetworkSecurity["OPEN"] = 1] = "OPEN";
    /**
     * WEP.
     */
    WifiNetworkSecurity[WifiNetworkSecurity["WEP"] = 2] = "WEP";
    /**
     * WPA1.
     */
    WifiNetworkSecurity[WifiNetworkSecurity["WPA1"] = 3] = "WPA1";
    /**
     * WPA2.
     */
    WifiNetworkSecurity[WifiNetworkSecurity["WPA2"] = 4] = "WPA2";
    /**
     * WPA3.
     */
    WifiNetworkSecurity[WifiNetworkSecurity["WPA3"] = 5] = "WPA3";
})(WifiNetworkSecurity = exports.WifiNetworkSecurity || (exports.WifiNetworkSecurity = {}));
/**
 * Airspeed sensor flags
 */
var AirspeedSensorFlags;
(function (AirspeedSensorFlags) {
    /**
     * Airspeed sensor is unhealthy
     */
    AirspeedSensorFlags[AirspeedSensorFlags["UNHEALTHY"] = 0] = "UNHEALTHY";
    /**
     * True if the data from this sensor is being actively used by the flight controller for guidance,
     * navigation or control.
     */
    AirspeedSensorFlags[AirspeedSensorFlags["USING"] = 1] = "USING";
})(AirspeedSensorFlags = exports.AirspeedSensorFlags || (exports.AirspeedSensorFlags = {}));
/**
 * Possible transport layers to set and get parameters via mavlink during a parameter transaction.
 */
var ParamTransactionTransport;
(function (ParamTransactionTransport) {
    /**
     * Transaction over param transport.
     */
    ParamTransactionTransport[ParamTransactionTransport["PARAM"] = 0] = "PARAM";
    /**
     * Transaction over param_ext transport.
     */
    ParamTransactionTransport[ParamTransactionTransport["PARAM_EXT"] = 1] = "PARAM_EXT";
})(ParamTransactionTransport = exports.ParamTransactionTransport || (exports.ParamTransactionTransport = {}));
/**
 * Possible parameter transaction actions.
 */
var ParamTransactionAction;
(function (ParamTransactionAction) {
    /**
     * Commit the current parameter transaction.
     */
    ParamTransactionAction[ParamTransactionAction["START"] = 0] = "START";
    /**
     * Commit the current parameter transaction.
     */
    ParamTransactionAction[ParamTransactionAction["COMMIT"] = 1] = "COMMIT";
    /**
     * Cancel the current parameter transaction.
     */
    ParamTransactionAction[ParamTransactionAction["CANCEL"] = 2] = "CANCEL";
})(ParamTransactionAction = exports.ParamTransactionAction || (exports.ParamTransactionAction = {}));
/**
 * Standard modes with a well understood meaning across flight stacks and vehicle types. For example,
 * most flight stack have the concept of a "return" or "RTL" mode that takes a vehicle to safety, even
 * though the precise mechanics of this mode may differ. Modes may be set using
 * MAV_CMD_DO_SET_STANDARD_MODE.
 */
var MavStandardMode;
(function (MavStandardMode) {
    /**
     * Non standard mode. This may be used when reporting the mode if the current flight mode is not a
     * standard mode.
     */
    MavStandardMode[MavStandardMode["NON_STANDARD"] = 0] = "NON_STANDARD";
    /**
     * Position mode (manual). Position-controlled and stabilized manual mode. When sticks are released
     * vehicles return to their level-flight orientation and hold both position and altitude against wind
     * and external forces. This mode can only be set by vehicles that can hold a fixed position.
     * Multicopter (MC) vehicles actively brake and hold both position and altitude against wind and
     * external forces. Hybrid MC/FW ("VTOL") vehicles first transition to multicopter mode (if needed) but
     * otherwise behave in the same way as MC vehicles. Fixed-wing (FW) vehicles must not support this
     * mode. Other vehicle types must not support this mode (this may be revisited through the PR process).
     *
     */
    MavStandardMode[MavStandardMode["POSITION_HOLD"] = 1] = "POSITION_HOLD";
    /**
     * Orbit (manual). Position-controlled and stabilized manual mode. The vehicle circles around a fixed
     * setpoint in the horizontal plane at a particular radius, altitude, and direction. Flight stacks may
     * further allow manual control over the setpoint position, radius, direction, speed, and/or altitude
     * of the circle, but this is not mandated. Flight stacks may support the
     * [MAV_CMD_DO_ORBIT](https://mavlink.io/en/messages/common.html#MAV_CMD_DO_ORBIT) for changing the
     * orbit parameters. MC and FW vehicles may support this mode. Hybrid MC/FW ("VTOL") vehicles may
     * support this mode in MC/FW or both modes; if the mode is not supported by the current configuration
     * the vehicle should transition to the supported configuration. Other vehicle types must not support
     * this mode (this may be revisited through the PR process).
     */
    MavStandardMode[MavStandardMode["ORBIT"] = 2] = "ORBIT";
    /**
     * Cruise mode (manual). Position-controlled and stabilized manual mode. When sticks are released
     * vehicles return to their level-flight orientation and hold their original track against wind and
     * external forces. Fixed-wing (FW) vehicles level orientation and maintain current track and altitude
     * against wind and external forces. Hybrid MC/FW ("VTOL") vehicles first transition to FW mode (if
     * needed) but otherwise behave in the same way as MC vehicles. Multicopter (MC) vehicles must not
     * support this mode. Other vehicle types must not support this mode (this may be revisited through the
     * PR process).
     */
    MavStandardMode[MavStandardMode["CRUISE"] = 3] = "CRUISE";
    /**
     * Altitude hold (manual). Altitude-controlled and stabilized manual mode. When sticks are released
     * vehicles return to their level-flight orientation and hold their altitude. MC vehicles continue with
     * existing momentum and may move with wind (or other external forces). FW vehicles continue with
     * current heading, but may be moved off-track by wind. Hybrid MC/FW ("VTOL") vehicles behave according
     * to their current configuration/mode (FW or MC). Other vehicle types must not support this mode (this
     * may be revisited through the PR process).
     */
    MavStandardMode[MavStandardMode["ALTITUDE_HOLD"] = 4] = "ALTITUDE_HOLD";
    /**
     * Return home mode (auto). Automatic mode that returns vehicle to home via a safe flight path. It may
     * also automatically land the vehicle (i.e. RTL). The precise flight path and landing behaviour depend
     * on vehicle configuration and type.
     */
    MavStandardMode[MavStandardMode["RETURN_HOME"] = 5] = "RETURN_HOME";
    /**
     * Safe recovery mode (auto). Automatic mode that takes vehicle to a predefined safe location via a
     * safe flight path (rally point or mission defined landing) . It may also automatically land the
     * vehicle. The precise return location, flight path, and landing behaviour depend on vehicle
     * configuration and type.
     */
    MavStandardMode[MavStandardMode["SAFE_RECOVERY"] = 6] = "SAFE_RECOVERY";
    /**
     * Mission mode (automatic). Automatic mode that executes MAVLink missions. Missions are executed from
     * the current waypoint as soon as the mode is enabled.
     */
    MavStandardMode[MavStandardMode["MISSION"] = 7] = "MISSION";
    /**
     * Land mode (auto). Automatic mode that lands the vehicle at the current location. The precise landing
     * behaviour depends on vehicle configuration and type.
     */
    MavStandardMode[MavStandardMode["LAND"] = 8] = "LAND";
    /**
     * Takeoff mode (auto). Automatic takeoff mode. The precise takeoff behaviour depends on vehicle
     * configuration and type.
     */
    MavStandardMode[MavStandardMode["TAKEOFF"] = 9] = "TAKEOFF";
})(MavStandardMode = exports.MavStandardMode || (exports.MavStandardMode = {}));
/**
 * Mode properties.
 */
var MavModeProperty;
(function (MavModeProperty) {
    /**
     * If set, this mode is an advanced mode. For example a rate-controlled manual mode might be advanced,
     * whereas a position-controlled manual mode is not. A GCS can optionally use this flag to configure
     * the UI for its intended users.
     */
    MavModeProperty[MavModeProperty["ADVANCED"] = 1] = "ADVANCED";
    /**
     * If set, this mode should not be added to the list of selectable modes. The mode might still be
     * selected by the FC directly (for example as part of a failsafe).
     */
    MavModeProperty[MavModeProperty["NOT_USER_SELECTABLE"] = 2] = "NOT_USER_SELECTABLE";
})(MavModeProperty = exports.MavModeProperty || (exports.MavModeProperty = {}));
/**
 * Battery status flags for fault, health and state indication.
 */
var MavBatteryStatusFlags;
(function (MavBatteryStatusFlags) {
    /**
     * The battery is not ready to use (fly). Set if the battery has faults or other conditions that make
     * it unsafe to fly with. Note: It will be the logical OR of other status bits (chosen by the
     * manufacturer/integrator).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["NOT_READY_TO_USE"] = 1] = "NOT_READY_TO_USE";
    /**
     * Battery is charging.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["CHARGING"] = 2] = "CHARGING";
    /**
     * Battery is cell balancing (during charging). Not ready to use
     * (MAV_BATTERY_STATUS_FLAGS_NOT_READY_TO_USE may be set).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["CELL_BALANCING"] = 4] = "CELL_BALANCING";
    /**
     * Battery cells are not balanced. Not ready to use.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_CELL_IMBALANCE"] = 8] = "FAULT_CELL_IMBALANCE";
    /**
     * Battery is auto discharging (towards storage level). Not ready to use
     * (MAV_BATTERY_STATUS_FLAGS_NOT_READY_TO_USE would be set).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["AUTO_DISCHARGING"] = 16] = "AUTO_DISCHARGING";
    /**
     * Battery requires service (not safe to fly). This is set at vendor discretion. It is likely to be set
     * for most faults, and may also be set according to a maintenance schedule (such as age, or number of
     * recharge cycles, etc.).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["REQUIRES_SERVICE"] = 32] = "REQUIRES_SERVICE";
    /**
     * Battery is faulty and cannot be repaired (not safe to fly). This is set at vendor discretion. The
     * battery should be disposed of safely.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["BAD_BATTERY"] = 64] = "BAD_BATTERY";
    /**
     * Automatic battery protection monitoring is enabled. When enabled, the system will monitor for
     * certain kinds of faults, such as cells being over-voltage. If a fault is triggered then and
     * protections are enabled then a safety fault (MAV_BATTERY_STATUS_FLAGS_FAULT_PROTECTION_SYSTEM) will
     * be set and power from the battery will be stopped. Note that battery protection monitoring should
     * only be enabled when the vehicle is landed. Once the vehicle is armed, or starts moving, the
     * protections should be disabled to prevent false positives from disabling the output.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["PROTECTIONS_ENABLED"] = 128] = "PROTECTIONS_ENABLED";
    /**
     * The battery fault protection system had detected a fault and cut all power from the battery. This
     * will only trigger if MAV_BATTERY_STATUS_FLAGS_PROTECTIONS_ENABLED is set. Other faults like
     * MAV_BATTERY_STATUS_FLAGS_FAULT_OVER_VOLT may also be set, indicating the cause of the protection
     * fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_PROTECTION_SYSTEM"] = 256] = "FAULT_PROTECTION_SYSTEM";
    /**
     * One or more cells are above their maximum voltage rating.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_OVER_VOLT"] = 512] = "FAULT_OVER_VOLT";
    /**
     * One or more cells are below their minimum voltage rating. A battery that had deep-discharged might
     * be irrepairably damaged, and set both MAV_BATTERY_STATUS_FLAGS_FAULT_UNDER_VOLT and
     * MAV_BATTERY_STATUS_FLAGS_BAD_BATTERY.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_UNDER_VOLT"] = 1024] = "FAULT_UNDER_VOLT";
    /**
     * Over-temperature fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_OVER_TEMPERATURE"] = 2048] = "FAULT_OVER_TEMPERATURE";
    /**
     * Under-temperature fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_UNDER_TEMPERATURE"] = 4096] = "FAULT_UNDER_TEMPERATURE";
    /**
     * Over-current fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_OVER_CURRENT"] = 8192] = "FAULT_OVER_CURRENT";
    /**
     * Short circuit event detected. The battery may or may not be safe to use (check other flags).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_SHORT_CIRCUIT"] = 16384] = "FAULT_SHORT_CIRCUIT";
    /**
     * Voltage not compatible with power rail voltage (batteries on same power rail should have similar
     * voltage).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_INCOMPATIBLE_VOLTAGE"] = 32768] = "FAULT_INCOMPATIBLE_VOLTAGE";
    /**
     * Battery firmware is not compatible with current autopilot firmware.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_INCOMPATIBLE_FIRMWARE"] = 65536] = "FAULT_INCOMPATIBLE_FIRMWARE";
    /**
     * Battery is not compatible due to cell configuration (e.g. 5s1p when vehicle requires 6s).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_INCOMPATIBLE_CELLS_CONFIGURATION"] = 131072] = "FAULT_INCOMPATIBLE_CELLS_CONFIGURATION";
    /**
     * Battery capacity_consumed and capacity_remaining values are relative to a full battery (they sum to
     * the total capacity of the battery). This flag would be set for a smart battery that can accurately
     * determine its remaining charge across vehicle reboots and discharge/recharge cycles. If unset the
     * capacity_consumed indicates the consumption since vehicle power-on, as measured using a power
     * monitor. The capacity_remaining, if provided, indicates the estimated remaining capacity on the
     * assumption that the battery was full on vehicle boot. If unset a GCS is recommended to advise that
     * users fully charge the battery on power on.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["CAPACITY_RELATIVE_TO_FULL"] = 262144] = "CAPACITY_RELATIVE_TO_FULL";
    /**
     * Reserved (not used). If set, this will indicate that an additional status field exists for higher
     * status values.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["EXTENDED"] = 4294967295] = "EXTENDED";
})(MavBatteryStatusFlags = exports.MavBatteryStatusFlags || (exports.MavBatteryStatusFlags = {}));
/**
 * Commands to be executed by the MAV. They can be executed on user request, or as part of a mission
 * script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is
 * as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list
 * is similar what ARINC 424 is for commercial aircraft: A data format how to interpret
 * waypoint/mission data. NaN and INT32_MAX may be used in float/integer params (respectively) to
 * indicate optional/default values (e.g. to use the component's current yaw or latitude rather than a
 * specific value). See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the
 * structure of the MAV_CMD entries
 */
var MavCmd;
(function (MavCmd) {
    /**
     * Fly a figure eight path as defined by the parameters. Set parameters to NaN/INT32_MAX (as
     * appropriate) to use system-default values. The command is intended for fixed wing vehicles (and VTOL
     * hybrids flying in fixed-wing mode), allowing POI tracking for gimbals that don't support infinite
     * rotation. This command only defines the flight path. Speed should be set independently (use e.g.
     * MAV_CMD_DO_CHANGE_SPEED). Yaw and other degrees of freedom are not specified, and will be
     * flight-stack specific (on vehicles where they can be controlled independent of the heading).
     *
     * @note has location and is destination
     *
     * @param1 Major Radius[m] Major axis radius of the figure eight. Positive: orbit the north circle clockwise. Negative: orbit the north circle counter-clockwise.
          NaN: The radius will be set to 2.5 times the minor radius and direction is clockwise.
          Must be greater or equal to two times the minor radius for feasible values.
     * @param2 Minor Radius[m] Minor axis radius of the figure eight. Defines the radius of the two circles that make up the figure. Negative value has no effect.
          NaN: The radius will be set to the default loiter radius.
     * @param4 Orientation[rad] Orientation of the figure eight major axis with respect to true north (range: [-pi,pi]). NaN: use default orientation aligned to true north.
     * @param5 Latitude/X Center point latitude/X coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle position, or current center if already loitering.
     * @param6 Longitude/Y Center point longitude/Y coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle position, or current center if already loitering.
     * @param7 Altitude/Z Center point altitude MSL/Z coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle altitude.
     */
    MavCmd[MavCmd["DO_FIGURE_EIGHT"] = 35] = "DO_FIGURE_EIGHT";
    /**
     * Request to start or end a parameter transaction. Multiple kinds of transport layers can be used to
     * exchange parameters in the transaction (param, param_ext and mavftp). The command response can
     * either be a success/failure or an in progress in case the receiving side takes some time to apply
     * the parameters.
     * @param1 Action Action to be performed (start, commit, cancel, etc.)
     * @param2 Transport Possible transport layers to set and get parameters via mavlink during a parameter transaction.
     * @param3 Transaction ID Identifier for a specific transaction.
     */
    MavCmd[MavCmd["PARAM_TRANSACTION"] = 900] = "PARAM_TRANSACTION";
    /**
     * Request a target system to start an upgrade of one (or all) of its components. For example, the
     * command might be sent to a companion computer to cause it to upgrade a connected flight controller.
     * The system doing the upgrade will report progress using the normal command protocol sequence for a
     * long running operation. Command protocol information: https://mavlink.io/en/services/command.html.
     * @param1 Component ID Component id of the component to be upgraded. If set to 0, all components should be upgraded.
     * @param2 Reboot (min: 0, max: 1, increment: 1) 0: Do not reboot component after the action is executed, 1: Reboot component after the action is executed.
     * @param3 Reserved
     * @param4 Reserved
     * @param5 Reserved
     * @param6 Reserved
     * @param7 WIP: upgrade progress report rate (can be used for more granular control).
     */
    MavCmd[MavCmd["DO_UPGRADE"] = 247] = "DO_UPGRADE";
    /**
     * Define start of a group of mission items. When control reaches this command a GROUP_START message is
     * emitted. The end of a group is marked using MAV_CMD_GROUP_END with the same group id. Group ids are
     * expected, but not required, to iterate sequentially. Groups can be nested.
     * @param1 Group ID (min: 0, max: 16777216, increment: 1) Mission-unique group id.
            Group id is limited because only 24 bit integer can be stored in 32 bit float.
     */
    MavCmd[MavCmd["GROUP_START"] = 301] = "GROUP_START";
    /**
     * Define end of a group of mission items. When control reaches this command a GROUP_END message is
     * emitted. The start of the group is marked is marked using MAV_CMD_GROUP_START with the same group
     * id. Group ids are expected, but not required, to iterate sequentially. Groups can be nested.
     * @param1 Group ID (min: 0, max: 16777216, increment: 1) Mission-unique group id.
            Group id is limited because only 24 bit integer can be stored in 32 bit float.
     */
    MavCmd[MavCmd["GROUP_END"] = 302] = "GROUP_END";
    /**
     * Enable the specified standard MAVLink mode. If the mode is not supported the vehicle should ACK with
     * MAV_RESULT_FAILED.
     * @param1 Standard Mode The mode to set.
     */
    MavCmd[MavCmd["DO_SET_STANDARD_MODE"] = 262] = "DO_SET_STANDARD_MODE";
    /**
     * Allows setting an AT S command of an SiK radio.
     * @param1 Radio instance The radio instance, one-based, 0 for all.
     * @param2 Index The Sx index, e.g. 3 for S3 which is NETID.
     * @param3 Value The value to set it to, e.g. default 25 for NETID
     */
    MavCmd[MavCmd["SET_AT_S_PARAM"] = 550] = "SET_AT_S_PARAM";
})(MavCmd = exports.MavCmd || (exports.MavCmd = {}));
/**
 * These flags indicate the sensor reporting capabilities for TARGET_ABSOLUTE.
 */
var TargetAbsoluteSensorCapabilityFlags;
(function (TargetAbsoluteSensorCapabilityFlags) {
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["POSITION"] = 1] = "POSITION";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["VELOCITY"] = 2] = "VELOCITY";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["ACCELERATION"] = 4] = "ACCELERATION";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["ATTITUDE"] = 8] = "ATTITUDE";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["RATES"] = 16] = "RATES";
})(TargetAbsoluteSensorCapabilityFlags = exports.TargetAbsoluteSensorCapabilityFlags || (exports.TargetAbsoluteSensorCapabilityFlags = {}));
/**
 * The frame of a target observation from an onboard sensor.
 */
var TargetObsFrame;
(function (TargetObsFrame) {
    /**
     * NED local tangent frame (x: North, y: East, z: Down) with origin fixed relative to earth.
     */
    TargetObsFrame[TargetObsFrame["LOCAL_NED"] = 0] = "LOCAL_NED";
    /**
     * FRD local frame aligned to the vehicle's attitude (x: Forward, y: Right, z: Down) with an origin
     * that travels with vehicle.
     */
    TargetObsFrame[TargetObsFrame["BODY_FRD"] = 1] = "BODY_FRD";
    /**
     * NED local tangent frame (x: North, y: East, z: Down) with an origin that travels with vehicle.
     */
    TargetObsFrame[TargetObsFrame["LOCAL_OFFSET_NED"] = 2] = "LOCAL_OFFSET_NED";
    /**
     * Other sensor frame for target observations neither in local NED nor in body FRD.
     */
    TargetObsFrame[TargetObsFrame["OTHER"] = 3] = "OTHER";
})(TargetObsFrame = exports.TargetObsFrame || (exports.TargetObsFrame = {}));
/**
 * Response from a PARAM_SET message when it is used in a transaction.
 */
class ParamAckTransaction extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.targetSystem = 0;
        this.targetComponent = 0;
        this.paramId = '';
        this.paramValue = 0;
        this.paramType = common_1.MavParamType[Object.keys(common_1.MavParamType)[0]];
        this.paramResult = common_1.ParamAck[Object.keys(common_1.ParamAck)[0]];
    }
}
exports.ParamAckTransaction = ParamAckTransaction;
ParamAckTransaction.MSG_ID = 19;
ParamAckTransaction.MSG_NAME = 'PARAM_ACK_TRANSACTION';
ParamAckTransaction.PAYLOAD_LENGTH = 24;
ParamAckTransaction.MAGIC_NUMBER = 137;
ParamAckTransaction.FIELDS = [
    new mavlink_1.MavLinkPacketField('param_value', 'paramValue', 0, false, 4, 'float', ''),
    new mavlink_1.MavLinkPacketField('target_system', 'targetSystem', 4, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('target_component', 'targetComponent', 5, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('param_id', 'paramId', 6, false, 1, 'char[]', '', 16),
    new mavlink_1.MavLinkPacketField('param_type', 'paramType', 22, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('param_result', 'paramResult', 23, false, 1, 'uint8_t', ''),
];
/**
 * Airspeed information from a sensor.
 */
class Airspeed extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.id = 0;
        this.airspeed = 0;
        this.temperature = 0;
        this.rawPress = 0;
        this.flags = AirspeedSensorFlags[Object.keys(AirspeedSensorFlags)[0]];
    }
}
exports.Airspeed = Airspeed;
Airspeed.MSG_ID = 295;
Airspeed.MSG_NAME = 'AIRSPEED';
Airspeed.PAYLOAD_LENGTH = 12;
Airspeed.MAGIC_NUMBER = 234;
Airspeed.FIELDS = [
    new mavlink_1.MavLinkPacketField('airspeed', 'airspeed', 0, false, 4, 'float', 'm/s'),
    new mavlink_1.MavLinkPacketField('raw_press', 'rawPress', 4, false, 4, 'float', 'hPa'),
    new mavlink_1.MavLinkPacketField('temperature', 'temperature', 8, false, 2, 'int16_t', 'cdegC'),
    new mavlink_1.MavLinkPacketField('id', 'id', 10, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 11, false, 1, 'uint8_t', ''),
];
/**
 * Detected WiFi network status information. This message is sent per each WiFi network detected in
 * range with known SSID and general status parameters.
 */
class WifiNetworkInfo extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.ssid = '';
        this.channelId = 0;
        this.signalQuality = 0;
        this.dataRate = 0;
        this.security = WifiNetworkSecurity[Object.keys(WifiNetworkSecurity)[0]];
    }
}
exports.WifiNetworkInfo = WifiNetworkInfo;
WifiNetworkInfo.MSG_ID = 298;
WifiNetworkInfo.MSG_NAME = 'WIFI_NETWORK_INFO';
WifiNetworkInfo.PAYLOAD_LENGTH = 37;
WifiNetworkInfo.MAGIC_NUMBER = 237;
WifiNetworkInfo.FIELDS = [
    new mavlink_1.MavLinkPacketField('data_rate', 'dataRate', 0, false, 2, 'uint16_t', 'MiB/s'),
    new mavlink_1.MavLinkPacketField('ssid', 'ssid', 2, false, 1, 'char[]', '', 32),
    new mavlink_1.MavLinkPacketField('channel_id', 'channelId', 34, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('signal_quality', 'signalQuality', 35, false, 1, 'uint8_t', '%'),
    new mavlink_1.MavLinkPacketField('security', 'security', 36, false, 1, 'uint8_t', ''),
];
/**
 * Battery dynamic information. This should be streamed (nominally at 1Hz). Static/invariant battery
 * information is sent in SMART_BATTERY_INFO. Note that smart batteries should set the
 * MAV_BATTERY_STATUS_FLAGS_CAPACITY_RELATIVE_TO_FULL bit to indicate that supplied capacity values are
 * relative to a battery that is known to be full. Power monitors would not set this bit, indicating
 * that capacity_consumed is relative to drone power-on, and that other values are estimated based on
 * the assumption that the battery was full on power-on.
 */
class BatteryStatusV2 extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.id = 0;
        this.temperature = 0;
        this.voltage = 0;
        this.current = 0;
        this.capacityConsumed = 0;
        this.capacityRemaining = 0;
        this.percentRemaining = 0;
        this.statusFlags = MavBatteryStatusFlags[Object.keys(MavBatteryStatusFlags)[0]];
    }
}
exports.BatteryStatusV2 = BatteryStatusV2;
BatteryStatusV2.MSG_ID = 369;
BatteryStatusV2.MSG_NAME = 'BATTERY_STATUS_V2';
BatteryStatusV2.PAYLOAD_LENGTH = 24;
BatteryStatusV2.MAGIC_NUMBER = 151;
BatteryStatusV2.FIELDS = [
    new mavlink_1.MavLinkPacketField('voltage', 'voltage', 0, false, 4, 'float', 'V'),
    new mavlink_1.MavLinkPacketField('current', 'current', 4, false, 4, 'float', 'A'),
    new mavlink_1.MavLinkPacketField('capacity_consumed', 'capacityConsumed', 8, false, 4, 'float', 'Ah'),
    new mavlink_1.MavLinkPacketField('capacity_remaining', 'capacityRemaining', 12, false, 4, 'float', 'Ah'),
    new mavlink_1.MavLinkPacketField('status_flags', 'statusFlags', 16, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('temperature', 'temperature', 20, false, 2, 'int16_t', 'cdegC'),
    new mavlink_1.MavLinkPacketField('id', 'id', 22, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('percent_remaining', 'percentRemaining', 23, false, 1, 'uint8_t', '%'),
];
/**
 * Basic component information data. Should be requested using MAV_CMD_REQUEST_MESSAGE on startup, or
 * when required.
 */
class ComponentInformationBasic extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.timeBootMs = 0;
        this.capabilities = common_1.MavProtocolCapability[Object.keys(common_1.MavProtocolCapability)[0]];
        this.vendorName = '';
        this.modelName = '';
        this.softwareVersion = '';
        this.hardwareVersion = '';
        this.serialNumber = '';
    }
}
exports.ComponentInformationBasic = ComponentInformationBasic;
ComponentInformationBasic.MSG_ID = 396;
ComponentInformationBasic.MSG_NAME = 'COMPONENT_INFORMATION_BASIC';
ComponentInformationBasic.PAYLOAD_LENGTH = 156;
ComponentInformationBasic.MAGIC_NUMBER = 129;
ComponentInformationBasic.FIELDS = [
    new mavlink_1.MavLinkPacketField('capabilities', 'capabilities', 0, false, 8, 'uint64_t', ''),
    new mavlink_1.MavLinkPacketField('time_boot_ms', 'timeBootMs', 8, false, 4, 'uint32_t', 'ms'),
    new mavlink_1.MavLinkPacketField('vendor_name', 'vendorName', 12, false, 1, 'char[]', '', 32),
    new mavlink_1.MavLinkPacketField('model_name', 'modelName', 44, false, 1, 'char[]', '', 32),
    new mavlink_1.MavLinkPacketField('software_version', 'softwareVersion', 76, false, 1, 'char[]', '', 24),
    new mavlink_1.MavLinkPacketField('hardware_version', 'hardwareVersion', 100, false, 1, 'char[]', '', 24),
    new mavlink_1.MavLinkPacketField('serial_number', 'serialNumber', 124, false, 1, 'char[]', '', 32),
];
/**
 * Emitted during mission execution when control reaches MAV_CMD_GROUP_START.
 */
class GroupStart extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.groupId = 0;
        this.missionChecksum = 0;
        this.timeUsec = BigInt(0);
    }
}
exports.GroupStart = GroupStart;
GroupStart.MSG_ID = 414;
GroupStart.MSG_NAME = 'GROUP_START';
GroupStart.PAYLOAD_LENGTH = 16;
GroupStart.MAGIC_NUMBER = 109;
GroupStart.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_usec', 'timeUsec', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('group_id', 'groupId', 8, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('mission_checksum', 'missionChecksum', 12, false, 4, 'uint32_t', ''),
];
/**
 * Emitted during mission execution when control reaches MAV_CMD_GROUP_END.
 */
class GroupEnd extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.groupId = 0;
        this.missionChecksum = 0;
        this.timeUsec = BigInt(0);
    }
}
exports.GroupEnd = GroupEnd;
GroupEnd.MSG_ID = 415;
GroupEnd.MSG_NAME = 'GROUP_END';
GroupEnd.PAYLOAD_LENGTH = 16;
GroupEnd.MAGIC_NUMBER = 161;
GroupEnd.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_usec', 'timeUsec', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('group_id', 'groupId', 8, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('mission_checksum', 'missionChecksum', 12, false, 4, 'uint32_t', ''),
];
/**
 * Get information about a particular flight modes. The message can be enumerated or requested for a
 * particular mode using MAV_CMD_REQUEST_MESSAGE. Specify 0 in param2 to request that the message is
 * emitted for all available modes or the specific index for just one mode. The modes must be
 * available/settable for the current vehicle/frame type. Each modes should only be emitted once (even
 * if it is both standard and custom).
 */
class AvailableModes extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.numberModes = 0;
        this.modeIndex = 0;
        this.standardMode = MavStandardMode[Object.keys(MavStandardMode)[0]];
        this.customMode = 0;
        this.properties = MavModeProperty[Object.keys(MavModeProperty)[0]];
        this.modeName = '';
    }
}
exports.AvailableModes = AvailableModes;
AvailableModes.MSG_ID = 435;
AvailableModes.MSG_NAME = 'AVAILABLE_MODES';
AvailableModes.PAYLOAD_LENGTH = 46;
AvailableModes.MAGIC_NUMBER = 134;
AvailableModes.FIELDS = [
    new mavlink_1.MavLinkPacketField('custom_mode', 'customMode', 0, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('properties', 'properties', 4, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('number_modes', 'numberModes', 8, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('mode_index', 'modeIndex', 9, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('standard_mode', 'standardMode', 10, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('mode_name', 'modeName', 11, false, 1, 'char[]', '', 35),
];
/**
 * Get the current mode. This should be emitted on any mode change, and broadcast at low rate
 * (nominally 0.5 Hz). It may be requested using MAV_CMD_REQUEST_MESSAGE.
 */
class CurrentMode extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.standardMode = MavStandardMode[Object.keys(MavStandardMode)[0]];
        this.customMode = 0;
        this.intendedCustomMode = 0;
    }
}
exports.CurrentMode = CurrentMode;
CurrentMode.MSG_ID = 436;
CurrentMode.MSG_NAME = 'CURRENT_MODE';
CurrentMode.PAYLOAD_LENGTH = 9;
CurrentMode.MAGIC_NUMBER = 193;
CurrentMode.FIELDS = [
    new mavlink_1.MavLinkPacketField('custom_mode', 'customMode', 0, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('intended_custom_mode', 'intendedCustomMode', 4, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('standard_mode', 'standardMode', 8, false, 1, 'uint8_t', ''),
];
/**
 * A change to the sequence number indicates that the set of AVAILABLE_MODES has changed. A receiver
 * must re-request all available modes whenever the sequence number changes. This is only emitted after
 * the first change and should then be broadcast at low rate (nominally 0.3 Hz) and on change.
 */
class AvailableModesMonitor extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.seq = 0;
    }
}
exports.AvailableModesMonitor = AvailableModesMonitor;
AvailableModesMonitor.MSG_ID = 437;
AvailableModesMonitor.MSG_NAME = 'AVAILABLE_MODES_MONITOR';
AvailableModesMonitor.PAYLOAD_LENGTH = 1;
AvailableModesMonitor.MAGIC_NUMBER = 30;
AvailableModesMonitor.FIELDS = [
    new mavlink_1.MavLinkPacketField('seq', 'seq', 0, false, 1, 'uint8_t', ''),
];
/**
 * Current motion information from sensors on a target
 */
class TargetAbsolute extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.timestamp = BigInt(0);
        this.id = 0;
        this.sensorCapabilities = TargetAbsoluteSensorCapabilityFlags[Object.keys(TargetAbsoluteSensorCapabilityFlags)[0]];
        this.lat = 0;
        this.lon = 0;
        this.alt = 0;
        this.vel = [];
        this.acc = [];
        this.qTarget = [];
        this.rates = [];
        this.positionStd = [];
        this.velStd = [];
        this.accStd = [];
    }
}
exports.TargetAbsolute = TargetAbsolute;
TargetAbsolute.MSG_ID = 510;
TargetAbsolute.MSG_NAME = 'TARGET_ABSOLUTE';
TargetAbsolute.PAYLOAD_LENGTH = 106;
TargetAbsolute.MAGIC_NUMBER = 245;
TargetAbsolute.FIELDS = [
    new mavlink_1.MavLinkPacketField('timestamp', 'timestamp', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('lat', 'lat', 8, false, 4, 'int32_t', 'degE7'),
    new mavlink_1.MavLinkPacketField('lon', 'lon', 12, false, 4, 'int32_t', 'degE7'),
    new mavlink_1.MavLinkPacketField('alt', 'alt', 16, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('vel', 'vel', 20, false, 4, 'float[]', 'm/s', 3),
    new mavlink_1.MavLinkPacketField('acc', 'acc', 32, false, 4, 'float[]', 'm/s/s', 3),
    new mavlink_1.MavLinkPacketField('q_target', 'qTarget', 44, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('rates', 'rates', 60, false, 4, 'float[]', 'rad/s', 3),
    new mavlink_1.MavLinkPacketField('position_std', 'positionStd', 72, false, 4, 'float[]', 'm', 2),
    new mavlink_1.MavLinkPacketField('vel_std', 'velStd', 80, false, 4, 'float[]', 'm/s', 3),
    new mavlink_1.MavLinkPacketField('acc_std', 'accStd', 92, false, 4, 'float[]', 'm/s/s', 3),
    new mavlink_1.MavLinkPacketField('id', 'id', 104, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('sensor_capabilities', 'sensorCapabilities', 105, false, 1, 'uint8_t', ''),
];
/**
 * The location of a target measured by MAV's onboard sensors.
 */
class TargetRelative extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.timestamp = BigInt(0);
        this.id = 0;
        this.frame = TargetObsFrame[Object.keys(TargetObsFrame)[0]];
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.posStd = [];
        this.yawStd = 0;
        this.qTarget = [];
        this.qSensor = [];
        this.type = common_1.LandingTargetType[Object.keys(common_1.LandingTargetType)[0]];
    }
}
exports.TargetRelative = TargetRelative;
TargetRelative.MSG_ID = 511;
TargetRelative.MSG_NAME = 'TARGET_RELATIVE';
TargetRelative.PAYLOAD_LENGTH = 71;
TargetRelative.MAGIC_NUMBER = 28;
TargetRelative.FIELDS = [
    new mavlink_1.MavLinkPacketField('timestamp', 'timestamp', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('x', 'x', 8, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('y', 'y', 12, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('z', 'z', 16, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('pos_std', 'posStd', 20, false, 4, 'float[]', 'm', 3),
    new mavlink_1.MavLinkPacketField('yaw_std', 'yawStd', 32, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('q_target', 'qTarget', 36, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('q_sensor', 'qSensor', 52, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('id', 'id', 68, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('frame', 'frame', 69, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('type', 'type', 70, false, 1, 'uint8_t', ''),
];
const common_2 = require("./common");
/**
 * Fly a figure eight path as defined by the parameters. Set parameters to NaN/INT32_MAX (as
 * appropriate) to use system-default values. The command is intended for fixed wing vehicles (and VTOL
 * hybrids flying in fixed-wing mode), allowing POI tracking for gimbals that don't support infinite
 * rotation. This command only defines the flight path. Speed should be set independently (use e.g.
 * MAV_CMD_DO_CHANGE_SPEED). Yaw and other degrees of freedom are not specified, and will be
 * flight-stack specific (on vehicles where they can be controlled independent of the heading).
 *
 * This command has location.
 * This command is destination.
 */
class DoFigureEightCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_FIGURE_EIGHT;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Major axis radius of the figure eight. Positive: orbit the north circle clockwise. Negative: orbit
     * the north circle counter-clockwise. NaN: The radius will be set to 2.5 times the minor radius and
     * direction is clockwise. Must be greater or equal to two times the minor radius for feasible values.
     *
     * @units m
     */
    get majorRadius() {
        return this._param1;
    }
    set majorRadius(value) {
        this._param1 = value;
    }
    /**
     * Minor axis radius of the figure eight. Defines the radius of the two circles that make up the
     * figure. Negative value has no effect. NaN: The radius will be set to the default loiter radius.
     *
     * @units m
     */
    get minorRadius() {
        return this._param2;
    }
    set minorRadius(value) {
        this._param2 = value;
    }
    /**
     * Orientation of the figure eight major axis with respect to true north (range: [-pi,pi]). NaN: use
     * default orientation aligned to true north.
     *
     * @units rad
     */
    get orientation() {
        return this._param4;
    }
    set orientation(value) {
        this._param4 = value;
    }
    /**
     * Center point latitude/X coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle position, or current center if
     * already loitering.
     */
    get latitude() {
        return this._param5;
    }
    set latitude(value) {
        this._param5 = value;
    }
    /**
     * Center point longitude/Y coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle position, or current center if
     * already loitering.
     */
    get longitude() {
        return this._param6;
    }
    set longitude(value) {
        this._param6 = value;
    }
    /**
     * Center point altitude MSL/Z coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle altitude.
     */
    get altitude() {
        return this._param7;
    }
    set altitude(value) {
        this._param7 = value;
    }
}
exports.DoFigureEightCommand = DoFigureEightCommand;
/**
 * Request to start or end a parameter transaction. Multiple kinds of transport layers can be used to
 * exchange parameters in the transaction (param, param_ext and mavftp). The command response can
 * either be a success/failure or an in progress in case the receiving side takes some time to apply
 * the parameters.
 */
class ParamTransactionCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.PARAM_TRANSACTION;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Action to be performed (start, commit, cancel, etc.)
     */
    get action() {
        return this._param1;
    }
    set action(value) {
        this._param1 = value;
    }
    /**
     * Possible transport layers to set and get parameters via mavlink during a parameter transaction.
     */
    get transport() {
        return this._param2;
    }
    set transport(value) {
        this._param2 = value;
    }
    /**
     * Identifier for a specific transaction.
     */
    get transactionId() {
        return this._param3;
    }
    set transactionId(value) {
        this._param3 = value;
    }
}
exports.ParamTransactionCommand = ParamTransactionCommand;
/**
 * Request a target system to start an upgrade of one (or all) of its components. For example, the
 * command might be sent to a companion computer to cause it to upgrade a connected flight controller.
 * The system doing the upgrade will report progress using the normal command protocol sequence for a
 * long running operation. Command protocol information: https://mavlink.io/en/services/command.html.
 */
class DoUpgradeCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_UPGRADE;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Component id of the component to be upgraded. If set to 0, all components should be upgraded.
     */
    get componentId() {
        return this._param1;
    }
    set componentId(value) {
        this._param1 = value;
    }
    /**
     * 0: Do not reboot component after the action is executed, 1: Reboot component after the action is
     * executed.
     *
     * @min: 0
     * @max: 1
     * @increment: 1
     */
    get reboot() {
        return this._param2;
    }
    set reboot(value) {
        this._param2 = value;
    }
}
exports.DoUpgradeCommand = DoUpgradeCommand;
/**
 * Define start of a group of mission items. When control reaches this command a GROUP_START message is
 * emitted. The end of a group is marked using MAV_CMD_GROUP_END with the same group id. Group ids are
 * expected, but not required, to iterate sequentially. Groups can be nested.
 */
class GroupStartCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.GROUP_START;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Mission-unique group id. Group id is limited because only 24 bit integer can be stored in 32 bit
     * float.
     *
     * @min: 0
     * @max: 16777216
     * @increment: 1
     */
    get groupId() {
        return this._param1;
    }
    set groupId(value) {
        this._param1 = value;
    }
}
exports.GroupStartCommand = GroupStartCommand;
/**
 * Define end of a group of mission items. When control reaches this command a GROUP_END message is
 * emitted. The start of the group is marked is marked using MAV_CMD_GROUP_START with the same group
 * id. Group ids are expected, but not required, to iterate sequentially. Groups can be nested.
 */
class GroupEndCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.GROUP_END;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Mission-unique group id. Group id is limited because only 24 bit integer can be stored in 32 bit
     * float.
     *
     * @min: 0
     * @max: 16777216
     * @increment: 1
     */
    get groupId() {
        return this._param1;
    }
    set groupId(value) {
        this._param1 = value;
    }
}
exports.GroupEndCommand = GroupEndCommand;
/**
 * Enable the specified standard MAVLink mode. If the mode is not supported the vehicle should ACK with
 * MAV_RESULT_FAILED.
 */
class DoSetStandardModeCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_SET_STANDARD_MODE;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * The mode to set.
     */
    get standardMode() {
        return this._param1;
    }
    set standardMode(value) {
        this._param1 = value;
    }
}
exports.DoSetStandardModeCommand = DoSetStandardModeCommand;
/**
 * Allows setting an AT S command of an SiK radio.
 */
class SetAtSParamCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.SET_AT_S_PARAM;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * The radio instance, one-based, 0 for all.
     */
    get radioInstance() {
        return this._param1;
    }
    set radioInstance(value) {
        this._param1 = value;
    }
    /**
     * The Sx index, e.g. 3 for S3 which is NETID.
     */
    get index() {
        return this._param2;
    }
    set index(value) {
        this._param2 = value;
    }
    /**
     * The value to set it to, e.g. default 25 for NETID
     */
    get value() {
        return this._param3;
    }
    set value(value) {
        this._param3 = value;
    }
}
exports.SetAtSParamCommand = SetAtSParamCommand;
exports.REGISTRY = {
    19: ParamAckTransaction,
    295: Airspeed,
    298: WifiNetworkInfo,
    369: BatteryStatusV2,
    396: ComponentInformationBasic,
    414: GroupStart,
    415: GroupEnd,
    435: AvailableModes,
    436: CurrentMode,
    437: AvailableModesMonitor,
    510: TargetAbsolute,
    511: TargetRelative,
};
exports.COMMANDS = {
    [MavCmd.DO_FIGURE_EIGHT]: DoFigureEightCommand,
    [MavCmd.PARAM_TRANSACTION]: ParamTransactionCommand,
    [MavCmd.DO_UPGRADE]: DoUpgradeCommand,
    [MavCmd.GROUP_START]: GroupStartCommand,
    [MavCmd.GROUP_END]: GroupEndCommand,
    [MavCmd.DO_SET_STANDARD_MODE]: DoSetStandardModeCommand,
    [MavCmd.SET_AT_S_PARAM]: SetAtSParamCommand,
};
//# sourceMappingURL=development.js.map