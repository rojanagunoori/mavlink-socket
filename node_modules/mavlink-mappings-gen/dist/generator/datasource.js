"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlDataSource = void 0;
const xml2js_1 = __importDefault(require("xml2js"));
const code_utils_1 = require("./code-utils");
const utils_1 = require("./utils");
const pipeable_1 = require("./pipeable");
class XmlDataSource {
    parse(xml) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield xml2js_1.default.parseStringPromise(xml, { explicitChildren: true, preserveChildrenOrder: true });
            return this.read(data.mavlink);
        });
    }
    read(mavlink) {
        const enumDefs = this.readEnumDefs(mavlink);
        const messageDefs = this.readMessageDefs(mavlink);
        const commandTypeDefs = this.readCommandDefs(enumDefs);
        this.updateCommandMessages(messageDefs);
        return { enumDefs, messageDefs, commandTypeDefs };
    }
    readEnumDefs(mavlink) {
        // read raw values from the source XML definition
        const result = mavlink.enums[0].enum.map((xml) => {
            var _a;
            return ({
                name: (0, code_utils_1.makeClassName)(xml.$.name),
                source: {
                    name: xml.$.name,
                },
                description: ((_a = xml.description) === null || _a === void 0 ? void 0 : _a.join(' ')) || '',
                values: this.readEnumValueDefs(xml)
            });
        });
        return (0, pipeable_1.pipeable)(result)
            // calculate common prefix for all enums to later on cut it off from the values
            .pipe(enums => enums.map(entry => (Object.assign(Object.assign({}, entry), { source: Object.assign(Object.assign({}, entry.source), { commonPrefix: (0, code_utils_1.calculateCommonPrefix)(entry) }) }))))
            // cut off common prefix from value names so that for the enum MavTest values are
            // 'FIRST' and 'SECOND' instead of 'MAV_TEST_FIRST' and 'MAV_TEST_SECOND'
            .pipe(enums => enums.map(entry => (Object.assign(Object.assign({}, entry), { values: entry.values.map(value => {
                var _a;
                return (Object.assign(Object.assign({}, value), { name: ((_a = value.name) === null || _a === void 0 ? void 0 : _a.startsWith(entry.source.commonPrefix || ''))
                        ? value.name.substring(entry.source.commonPrefix.length)
                        : value.name }));
            }) }))))
            // check values that start with a digit in which case use the original source instead
            .pipe(enums => enums.map(entry => (Object.assign(Object.assign({}, entry), { values: entry.values.map(value => (Object.assign(Object.assign({}, value), { name: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(value.name[0])
                    ? value.source.name
                    : value.name }))) }))));
    }
    readEnumValueDefs(xml) {
        return xml.entry.map((xml) => {
            var _a;
            return ({
                source: {
                    name: xml.$.name,
                    value: xml.$.value,
                },
                name: xml.$.name,
                value: xml.$.value,
                description: ((_a = xml.description) === null || _a === void 0 ? void 0 : _a.map((s) => String(s)).filter((s) => s.trim() !== '[object Object]').join(' ')) || '',
                params: this.readEnumValueParamDefs(xml),
                hasLocation: xml.$.hasLocation === 'true',
                isDestination: xml.$.isDestination === 'true',
            });
        });
    }
    readEnumValueParamDefs(xml) {
        return (xml.param || []).map((xml) => ({
            units: xml.$.units,
            label: xml.$.label,
            description: xml._,
            increment: xml.$.increment,
            index: xml.$.index,
            name: xml.$.name,
            minValue: xml.$.minValue,
            maxValue: xml.$.maxValue,
        }));
    }
    readMessageDefs(mavlink) {
        const isWorkInProgress = (message) => message.$$.some((item) => item['#name'] === 'wip');
        const result = mavlink.messages[0].message.map((message) => {
            var _a;
            return ({
                source: {
                    xml: message,
                    name: message.$.name,
                },
                id: message.$.id,
                name: (0, code_utils_1.makeClassName)(message.$.name),
                description: ((_a = message.description) === null || _a === void 0 ? void 0 : _a.join(' ')) || '',
                deprecated: (!message.deprecated) ? undefined : {
                    since: message.deprecated[0].$.since,
                    replacedBy: message.deprecated[0].$.replaced_by,
                    description: message.deprecated[0]._,
                },
                workInProgress: isWorkInProgress(message),
                fields: this.readMessageFieldDefs(message),
                wip: Boolean(message.wip)
            });
        }).filter((x) => !x.wip);
        return (0, pipeable_1.pipeable)(result)
            // calculate payload length
            .pipe((messages) => messages.map((message) => (Object.assign(Object.assign({}, message), { payloadLength: message.fields.reduce((acc, field) => acc + field.size, 0) }))))
            // calculate magic numbers
            .pipe((messages) => messages.map((message) => (Object.assign(Object.assign({}, message), { magic: (0, utils_1.calculateCrcExtra)(message.source.name, message.fields) }))));
    }
    readMessageFieldDefs(xml) {
        // gather message fields
        //
        // The order does matter and there are things like <wip> and <extensions> that also need
        // to be understood to properly collect fields
        let isExtensionField = false;
        const result = xml.$$
            .map((item) => {
            if (item['#name'] === 'extensions') {
                isExtensionField = true;
                return null;
            }
            else if (item['#name'] === 'field') {
                const field = item;
                const entry = {
                    source: {
                        name: field.$.name,
                        type: field.$.type,
                        enum: field.$.enum,
                    },
                    name: (0, code_utils_1.snakeToCamel)(field.$.name),
                    extension: isExtensionField,
                    description: field._ || '',
                    type: field.$.enum ? (0, code_utils_1.makeEnumFieldType)(field.$.type, (0, code_utils_1.makeClassName)(field.$.enum)) : (0, code_utils_1.extractArrayType)(field.$.type),
                    arrayLength: (0, code_utils_1.extractArraySize)(field.$.type) || null,
                    size: (0, code_utils_1.getTypeSize)(field.$.type) * ((0, code_utils_1.extractArraySize)(field.$.type) || 1),
                    fieldType: (0, code_utils_1.extractArrayType)(field.$.type),
                    fieldSize: (0, code_utils_1.getTypeSize)(field.$.type),
                    itemType: (0, code_utils_1.extractArrayItemType)(field.$.type),
                    units: field.$.units || '',
                };
                // cleanup type names
                if (entry.type === 'char[]')
                    entry.type = 'string';
                return entry;
            }
            else {
                return null;
            }
        })
            // filter out empty/unknown items like "wip"
            .filter((entry) => entry);
        return result;
    }
    readCommandDefs(enums) {
        var _a;
        const result = (((_a = enums.find(e => e.name === 'MavCmd')) === null || _a === void 0 ? void 0 : _a.values) || [])
            .map(command => (Object.assign(Object.assign({}, command), { field: (0, code_utils_1.nameToClassName)(command.name), params: command.params
                .filter(param => param.label)
                .map(param => (Object.assign(Object.assign({}, param), { name: (0, code_utils_1.labelToIdentifier)(param.label), orgName: param.label }))) })))
            .filter(command => !command.workInProgress);
        return (0, pipeable_1.pipeable)(result);
    }
    updateCommandMessages(messageDefs) {
        const commandInt = messageDefs.find(message => message.name === 'CommandInt');
        const commandLong = messageDefs.find(message => message.name === 'CommandLong');
        // for CommandInt override the fields
        if (commandInt) {
            const FIELDS = ['param1', 'param2', 'param3', 'param4', 'x', 'y', 'z'];
            commandInt.fields
                .filter(field => FIELDS.includes(field.name))
                .forEach(field => {
                const MAPPINGS = {
                    'x': 'param5',
                    'y': 'param6',
                    'z': 'param7',
                };
                field.name = '_' + (MAPPINGS[field.name] || field.name);
            });
        }
        // for CommandLong override the fields
        if (commandLong) {
            commandLong.fields
                .filter(field => field.name.startsWith('param'))
                .forEach(field => field.name = '_' + field.name);
        }
    }
}
exports.XmlDataSource = XmlDataSource;
