"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAll = exports.processRegistries = exports.generateMagicNumbers = exports.generateCommandRegistry = exports.generateCommands = exports.generateCommand = exports.generateCommandParamGetterAndSetter = exports.generateCommandParamDoc = exports.generateCommandClass = exports.generateCommandParams = exports.generateCommandConstructor = exports.generateCommandDoc = exports.generateMessageRegistry = exports.generateMessages = exports.generateMessage = exports.generateMessageClass = exports.generateMessageFields = exports.generateMessageConstructor = exports.generateMessageDefinitionFields = exports.generateMessageStaticDeclarations = exports.generateMessageClassHeader = exports.generateMessageDoc = exports.generateEnumValueParams = exports.generateEnumValue = exports.generateEnumValues = exports.generateEnum = exports.generateEnums = void 0;
const code_utils_1 = require("./code-utils");
const datasource_1 = require("./datasource");
function generateEnums(output, enums) {
    const maxEnumValueNameLength = (0, code_utils_1.calculateMaxEnumValueNameLength)(enums);
    enums.forEach(entry => {
        generateEnum(output, maxEnumValueNameLength, entry);
    });
}
exports.generateEnums = generateEnums;
function generateEnum(output, maxEnumValueNameLength, entry) {
    output.write('');
    // generate enum description
    output.write('/**');
    if (entry.description.length > 0) {
        output.write(` * ${entry.description.join('\n * ')}`);
    }
    else {
        output.write(` * ${entry.source.name}`);
    }
    output.write(' */');
    // generate enum declaration
    output.write(`export enum ${entry.name} {`);
    // generate enum values
    generateEnumValues(output, maxEnumValueNameLength, entry.values);
    output.write(`}`);
}
exports.generateEnum = generateEnum;
function generateEnumValues(output, maxEnumValueNameLength, values) {
    values.forEach((value, index) => {
        generateEnumValue(output, maxEnumValueNameLength, index, value);
    });
}
exports.generateEnumValues = generateEnumValues;
function generateEnumValue(output, maxEnumValueNameLength, index, value) {
    const props = [
        value.hasLocation ? `has location` : '',
        value.isDestination ? 'is destination' : '',
    ].filter(s => s);
    if (value.description.length > 0 || value.params.length > 0 || props.length || value.hasLocation || value.isDestination) {
        if (index > 0) {
            output.write('');
        }
        output.write('  /**');
        if (value.description.length > 0) {
            output.write(`   * ${value.description.join('\n   * ')}`);
        }
        if (props.length > 0) {
            if (value.description.length > 0) {
                output.write(`   *`);
            }
            output.write(`   * @note ${props.join(' and ')}`);
        }
        generateEnumValueParams(output, props.length > 0, value);
        output.write('   */');
    }
    const padding = ''.padEnd(maxEnumValueNameLength - value.name.length, ' ');
    output.write(`  '${value.name}'${padding} = ${value.value},`);
}
exports.generateEnumValue = generateEnumValue;
function generateEnumValueParams(output, hasProps, value) {
    if (value.params.length > 0) {
        const params = value.params;
        if (value.description.length > 0 && hasProps) {
            output.write(`   *`);
        }
        params.forEach(param => {
            const units = param.units ? `[${param.units}]` : '';
            const label = param.label ? ` ${param.label}` : '';
            const parts = [
                param.minValue ? `min: ${param.minValue}` : '',
                param.maxValue ? `max: ${param.maxValue}` : '',
                param.increment ? `increment: ${param.increment}` : '',
            ].filter(s => s).join(', ');
            const meta = parts ? ` (${parts})` : '';
            const description = param.description ? ` ${param.description}` : '';
            const content = `${label}${units}${meta}${description}`;
            if (content) {
                output.write(`   * @param${param.index}${content}`);
            }
        });
    }
}
exports.generateEnumValueParams = generateEnumValueParams;
function generateMessageDoc(output, message) {
    output.write('/**');
    if (message.description.length > 0) {
        output.write(` * ${message.description.join('\n * ')}`);
    }
    else {
        output.write(` * ${message.source.name}`);
    }
    // generate deprecation information
    if (message.deprecated) {
        const description = message.deprecated.description ? `; ${message.deprecated.description}` : '';
        const since = message.deprecated.since || 'unknown';
        const replacedBy = message.deprecated.replacedBy || 'unknown';
        output.write(` *`);
        output.write(` * @deprecated since ${since}, replaced by ${replacedBy}${description}`);
    }
    output.write(' */');
}
exports.generateMessageDoc = generateMessageDoc;
function generateMessageClassHeader(output, message) {
    output.write(`export class ${message.name} extends MavLinkData {`);
}
exports.generateMessageClassHeader = generateMessageClassHeader;
function generateMessageStaticDeclarations(output, message) {
    // generate static fields
    output.write(`  static MSG_ID = ${message.id}`);
    output.write(`  static MSG_NAME = '${message.source.name}'`);
    output.write(`  static PAYLOAD_LENGTH = ${message.payloadLength}`);
    output.write(`  static MAGIC_NUMBER = ${message.magic}`);
    output.write(``);
}
exports.generateMessageStaticDeclarations = generateMessageStaticDeclarations;
function generateMessageDefinitionFields(output, fields) {
    output.write('  static FIELDS = [');
    // base fields go first; they are sorted from the largest fields to the smallest
    // if the size is the same then the order from xml is preserved
    const sortedFields = [...fields];
    sortedFields.sort((f1, f2) => f2.fieldSize - f1.fieldSize);
    let offset = 0;
    sortedFields
        .filter(field => !field.extension)
        .forEach(field => {
        if (field.arrayLength) {
            output.write(`    new MavLinkPacketField('${field.source.name}', '${field.name}', ${offset}, false, ${field.fieldSize}, '${field.fieldType}', '${field.units}', ${field.arrayLength}),`);
        }
        else {
            output.write(`    new MavLinkPacketField('${field.source.name}', '${field.name}', ${offset}, false, ${field.fieldSize}, '${field.fieldType}', '${field.units}'),`);
        }
        offset += field.size;
    });
    // extension fields retain their original definition order and are but after base fields
    fields
        .filter(field => field.extension)
        .forEach(field => {
        if (field.arrayLength) {
            output.write(`    new MavLinkPacketField('${field.source.name}', '${field.name}', ${offset}, true, ${field.fieldSize}, '${field.fieldType}', '${field.units}', ${field.arrayLength}),`);
        }
        else {
            output.write(`    new MavLinkPacketField('${field.source.name}', '${field.name}', ${offset}, true, ${field.fieldSize}, '${field.fieldType}', '${field.units}'),`);
        }
        offset += field.size;
    });
    output.write('  ]');
    output.write('');
}
exports.generateMessageDefinitionFields = generateMessageDefinitionFields;
function generateMessageConstructor(output, fields) {
    output.write(`  constructor() {`);
    output.write(`    super()`);
    fields.forEach(field => {
        const isStringType = (f) => f.type.startsWith('char') || f.type === 'string';
        const is64BitField = (f) => f.type.includes('64');
        const isEnum = (f) => f.source.enum;
        const initValue = isStringType(field)
            ? '\'\''
            : is64BitField(field)
                ? 'BigInt(0)'
                : isEnum(field)
                    ? `${field.type}[Object.keys(${field.type})[0]]` // this assumes there is at least one value in the enum
                    : 0;
        const init = field.arrayLength && field.type !== 'string' ? `[]` : initValue;
        output.write(`    this.${field.name} = ${init}`);
    });
    output.write(`  }`);
    if (fields.length > 0)
        output.write('');
}
exports.generateMessageConstructor = generateMessageConstructor;
function generateMessageFields(output, fields) {
    // generate fields
    fields.forEach((field, index, fields) => {
        if (field.description.length > 0 || field.units) {
            output.write('  /**');
            output.write(`   * ${field.description.join('\n   * ')}`);
            if (field.units) {
                output.write(`   * Units: ${field.units}`);
            }
            output.write('   */');
        }
        output.write(`  ${field.name}: ${field.type}`);
        if (fields.length - 1 > index) {
            output.write('');
        }
    });
    output.write(`}`);
}
exports.generateMessageFields = generateMessageFields;
function generateMessageClass(output, message) {
    generateMessageClassHeader(output, message);
    generateMessageStaticDeclarations(output, message);
    generateMessageDefinitionFields(output, message.fields);
    generateMessageConstructor(output, message.fields);
    generateMessageFields(output, message.fields);
}
exports.generateMessageClass = generateMessageClass;
function generateMessage(output, message) {
    generateMessageDoc(output, message);
    generateMessageClass(output, message);
}
exports.generateMessage = generateMessage;
function generateMessages(output, messages) {
    messages.forEach(message => {
        output.write();
        generateMessage(output, message);
    });
}
exports.generateMessages = generateMessages;
function generateMessageRegistry(output, messages) {
    output.write();
    output.write(`export const REGISTRY: MavLinkPacketRegistry = {`);
    messages.forEach(message => {
        output.write(`  ${message.id}: ${message.name},`);
    });
    output.write('}');
    output.write();
}
exports.generateMessageRegistry = generateMessageRegistry;
function generateCommandDoc(output, command) {
    if (command.description || command.hasLocation || command.isDestination) {
        output.write('/**');
        if (command.description.length > 0) {
            output.write(` * ${command.description.join('\n * ')}`);
        }
        if (command.hasLocation || command.isDestination) {
            if (command.description.length > 0) {
                output.write(' *');
            }
            if (command.hasLocation) {
                output.write(` * This command has location.`);
            }
            if (command.isDestination) {
                output.write(` * This command is destination.`);
            }
        }
        output.write(' */');
    }
}
exports.generateCommandDoc = generateCommandDoc;
function generateCommandConstructor(output, command) {
    output.write(`  constructor(targetSystem = 1, targetComponent = 1) {`);
    output.write(`    super()`);
    output.write(`    this.command = MavCmd.${command.name} as number`);
    output.write(`    this.targetSystem = targetSystem`);
    output.write(`    this.targetComponent = targetComponent`);
    output.write(`  }`);
}
exports.generateCommandConstructor = generateCommandConstructor;
function generateCommandParams(output, params) {
    params.forEach((param, index) => {
        if (index > 0)
            output.write();
        generateCommandParamDoc(output, param);
        generateCommandParamGetterAndSetter(output, param);
    });
}
exports.generateCommandParams = generateCommandParams;
function generateCommandClass(output, command) {
    output.write(`export class ${command.field} extends CommandLong {`);
    generateCommandConstructor(output, command);
    if (command.params.length > 0) {
        output.write(``);
    }
    generateCommandParams(output, command.params);
    output.write(`}`);
}
exports.generateCommandClass = generateCommandClass;
function generateCommandParamDoc(output, param) {
    if (param.description || param.label) {
        const label = [...param.description || param.label || '']
            .filter(x => x)
            .map(s => `   * ${s}`);
        const parts = [
            param.units ? `   * @units ${param.units}` : '',
            param.minValue ? `   * @min: ${param.minValue}` : '',
            param.maxValue ? `   * @max: ${param.maxValue}` : '',
            param.increment ? `   * @increment: ${param.increment}` : '',
        ].filter(s => s);
        if (parts.length > 0 && label.length > 0) {
            label.push(`   *`);
        }
        label.reverse().forEach(s => parts.unshift(s));
        if (parts.length > 0) {
            parts.unshift(`  /**`);
        }
        if (parts.length > 0) {
            output.write(parts.join('\n'));
        }
        if (parts.length > 0) {
            output.write(`   */`);
        }
    }
}
exports.generateCommandParamDoc = generateCommandParamDoc;
function generateCommandParamGetterAndSetter(output, param) {
    output.write(`  get ${param.name}() {`);
    output.write(`    return this._param${param.index}`);
    output.write(`  }`);
    output.write(`  set ${param.name}(value: number) {`);
    output.write(`    this._param${param.index} = value`);
    output.write(`  }`);
}
exports.generateCommandParamGetterAndSetter = generateCommandParamGetterAndSetter;
function generateCommand(output, command) {
    generateCommandDoc(output, command);
    generateCommandClass(output, command);
}
exports.generateCommand = generateCommand;
function generateCommands(output, moduleName, commands) {
    if (commands.length > 0) {
        if (moduleName !== 'common') {
            output.write('');
            output.write('import { CommandLong } from \'./common\'');
            output.write('');
        }
        commands.forEach((command, index) => {
            if (index > 0)
                output.write('');
            generateCommand(output, command);
        });
    }
}
exports.generateCommands = generateCommands;
function generateCommandRegistry(output, commands) {
    if (commands.length > 0) {
        output.write(`export const COMMANDS: MavLinkCommandRegistry = {`);
        commands.forEach(command => {
            output.write(`  [MavCmd.${command.name}]: ${command.field},`);
        });
        output.write(`}`);
        output.write();
    }
}
exports.generateCommandRegistry = generateCommandRegistry;
function generateMagicNumbers(magicNumbers) {
    return [
        `export const MSG_ID_MAGIC_NUMBER: Record<string, number> = {`,
        ...Object.entries(magicNumbers).map(([msgid, magic]) => `  '${msgid}': ${magic},`, ''),
        `}`
    ].join('\n') + '\n';
}
exports.generateMagicNumbers = generateMagicNumbers;
function processEnums(output, enumDefs) {
    const enums = enumDefs
        // update descriptions to be multiline strings with a maximum width
        .pipe(enums => enums.map(entry => (Object.assign(Object.assign({}, entry), { description: (0, code_utils_1.matchTextToWidth)(entry.description), values: entry.values.map(value => (Object.assign(Object.assign({}, value), { description: (0, code_utils_1.matchTextToWidth)(value.description) }))) }))));
    generateEnums(output, enums);
    return enums;
}
function processMessages(output, messageDefs) {
    const FIXED_MESSAGE_NAMES = {
        '111': 'TimeSync',
        '138': 'MotionCaptureAttPos',
        '152': 'MemInfo',
        '164': 'SimState',
        '165': 'HwStatus',
        '173': 'RangeFinder',
        '177': 'CompassMotStatus',
        '253': 'StatusText',
    };
    const messages = messageDefs
        // update descriptions to be multiline strings with a maximum width
        // fix some messages because they lack underscore in the original name
        .pipe(messages => messages.map(message => (Object.assign(Object.assign({}, message), { name: FIXED_MESSAGE_NAMES[message.id] || message.name, description: (0, code_utils_1.matchTextToWidth)(message.description), fields: message.fields.map(field => (Object.assign(Object.assign({}, field), { description: (0, code_utils_1.matchTextToWidth)(field.description) }))) }))));
    generateMessages(output, messages);
    return messages;
}
function processCommands(output, moduleName, commandTypeDefs) {
    const commands = commandTypeDefs
        .pipe(commands => commands.map(command => (Object.assign(Object.assign({}, command), { description: (0, code_utils_1.matchTextToWidth)(command.description), params: command.params
            .map(param => (Object.assign(Object.assign({}, param), { description: (0, code_utils_1.matchTextToWidth)(param.description) })))
            .filter(param => param.name) }))));
    generateCommands(output, moduleName, commands);
    return commands;
}
function processRegistries(output, messages, commands) {
    generateMessageRegistry(output, messages);
    generateCommandRegistry(output, commands);
}
exports.processRegistries = processRegistries;
function generateAll(input, output, moduleName = '') {
    return __awaiter(this, void 0, void 0, function* () {
        const { enumDefs, messageDefs, commandTypeDefs } = yield new datasource_1.XmlDataSource().parse(input);
        const enums = processEnums(output, enumDefs);
        const messages = processMessages(output, messageDefs);
        const commands = processCommands(output, moduleName, commandTypeDefs);
        processRegistries(output, messages, commands);
        return { enums, messages, commands };
    });
}
exports.generateAll = generateAll;
